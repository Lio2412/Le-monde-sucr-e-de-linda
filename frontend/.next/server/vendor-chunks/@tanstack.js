"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tanstack";
exports.ids = ["vendor-chunks/@tanstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tanstack/react-virtual/dist/esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll),\n/* harmony export */   measureElement: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect),\n/* harmony export */   useVirtualizer: () => (/* binding */ useVirtualizer),\n/* harmony export */   useWindowVirtualizer: () => (/* binding */ useWindowVirtualizer),\n/* harmony export */   windowScroll: () => (/* reexport safe */ _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tanstack/virtual-core */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\");\n\n\n\n\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useVirtualizerBase(options) {\n    const rerender = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(()=>({}), {})[1];\n    const resolvedOptions = {\n        ...options,\n        onChange: (instance2, sync)=>{\n            var _a;\n            if (sync) {\n                (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(rerender);\n            } else {\n                rerender();\n            }\n            (_a = options.onChange) == null ? void 0 : _a.call(options, instance2, sync);\n        }\n    };\n    const [instance] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.Virtualizer(resolvedOptions));\n    instance.setOptions(resolvedOptions);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._didMount();\n    }, []);\n    useIsomorphicLayoutEffect(()=>{\n        return instance._willUpdate();\n    });\n    return instance;\n}\nfunction useVirtualizer(options) {\n    return useVirtualizerBase({\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeElementOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.elementScroll,\n        ...options\n    });\n}\nfunction useWindowVirtualizer(options) {\n    return useVirtualizerBase({\n        getScrollElement: ()=>typeof document !== \"undefined\" ? window : null,\n        observeElementRect: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowRect,\n        observeElementOffset: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.observeWindowOffset,\n        scrollToFn: _tanstack_virtual_core__WEBPACK_IMPORTED_MODULE_2__.windowScroll,\n        initialOffset: ()=>typeof document !== \"undefined\" ? window.scrollY : 0,\n        ...options\n    });\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3JlYWN0LXZpcnR1YWwvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNPO0FBQzhIO0FBQzdIO0FBQ3ZDLE1BQU1TLDRCQUE0QixPQUFPQyxhQUFhLGNBQWNWLGtEQUFxQixHQUFHQSw0Q0FBZTtBQUMzRyxTQUFTYSxtQkFBbUJDLE9BQU87SUFDakMsTUFBTUMsV0FBV2YsNkNBQWdCLENBQUMsSUFBTyxFQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRTtJQUNwRCxNQUFNaUIsa0JBQWtCO1FBQ3RCLEdBQUdILE9BQU87UUFDVkksVUFBVSxDQUFDQyxXQUFXQztZQUNwQixJQUFJQztZQUNKLElBQUlELE1BQU07Z0JBQ1JuQixvREFBU0EsQ0FBQ2M7WUFDWixPQUFPO2dCQUNMQTtZQUNGO1lBQ0NNLENBQUFBLEtBQUtQLFFBQVFJLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSUcsR0FBR0MsSUFBSSxDQUFDUixTQUFTSyxXQUFXQztRQUN6RTtJQUNGO0lBQ0EsTUFBTSxDQUFDRyxTQUFTLEdBQUd2QiwyQ0FBYyxDQUMvQixJQUFNLElBQUlFLCtEQUFXQSxDQUFDZTtJQUV4Qk0sU0FBU0UsVUFBVSxDQUFDUjtJQUNwQlIsMEJBQTBCO1FBQ3hCLE9BQU9jLFNBQVNHLFNBQVM7SUFDM0IsR0FBRyxFQUFFO0lBQ0xqQiwwQkFBMEI7UUFDeEIsT0FBT2MsU0FBU0ksV0FBVztJQUM3QjtJQUNBLE9BQU9KO0FBQ1Q7QUFDQSxTQUFTSyxlQUFlZCxPQUFPO0lBQzdCLE9BQU9ELG1CQUFtQjtRQUN4QlIsa0JBQWtCQSx3RUFBQUE7UUFDbEJELG9CQUFvQkEsMEVBQUFBO1FBQ3BCeUIsWUFBWTFCLGlFQUFhQTtRQUN6QixHQUFHVyxPQUFPO0lBQ1o7QUFDRjtBQUNBLFNBQVNnQixxQkFBcUJoQixPQUFPO0lBQ25DLE9BQU9ELG1CQUFtQjtRQUN4QmtCLGtCQUFrQixJQUFNLE9BQU9yQixhQUFhLGNBQWNzQixTQUFTO1FBQ25FM0Isb0JBQW9CRyxxRUFBaUJBO1FBQ3JDSixzQkFBc0JHLHVFQUFtQkE7UUFDekNzQixZQUFZdkIsZ0VBQVlBO1FBQ3hCMkIsZUFBZSxJQUFNLE9BQU92QixhQUFhLGNBQWNzQixPQUFPRSxPQUFPLEdBQUc7UUFDeEUsR0FBR3BCLE9BQU87SUFDWjtBQUNGO0FBSUUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZS1tb25kZS1zdWNyZS1kZS1saW5kYS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svcmVhY3QtdmlydHVhbC9kaXN0L2VzbS9pbmRleC5qcz85YmY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZmx1c2hTeW5jIH0gZnJvbSBcInJlYWN0LWRvbVwiO1xuaW1wb3J0IHsgVmlydHVhbGl6ZXIsIGVsZW1lbnRTY3JvbGwsIG9ic2VydmVFbGVtZW50T2Zmc2V0LCBvYnNlcnZlRWxlbWVudFJlY3QsIHdpbmRvd1Njcm9sbCwgb2JzZXJ2ZVdpbmRvd09mZnNldCwgb2JzZXJ2ZVdpbmRvd1JlY3QgfSBmcm9tIFwiQHRhbnN0YWNrL3ZpcnR1YWwtY29yZVwiO1xuZXhwb3J0ICogZnJvbSBcIkB0YW5zdGFjay92aXJ0dWFsLWNvcmVcIjtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyBSZWFjdC51c2VMYXlvdXRFZmZlY3QgOiBSZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiB1c2VWaXJ0dWFsaXplckJhc2Uob3B0aW9ucykge1xuICBjb25zdCByZXJlbmRlciA9IFJlYWN0LnVzZVJlZHVjZXIoKCkgPT4gKHt9KSwge30pWzFdO1xuICBjb25zdCByZXNvbHZlZE9wdGlvbnMgPSB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBvbkNoYW5nZTogKGluc3RhbmNlMiwgc3luYykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgZmx1c2hTeW5jKHJlcmVuZGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcmVuZGVyKCk7XG4gICAgICB9XG4gICAgICAoX2EgPSBvcHRpb25zLm9uQ2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCBpbnN0YW5jZTIsIHN5bmMpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgW2luc3RhbmNlXSA9IFJlYWN0LnVzZVN0YXRlKFxuICAgICgpID0+IG5ldyBWaXJ0dWFsaXplcihyZXNvbHZlZE9wdGlvbnMpXG4gICk7XG4gIGluc3RhbmNlLnNldE9wdGlvbnMocmVzb2x2ZWRPcHRpb25zKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9kaWRNb3VudCgpO1xuICB9LCBbXSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBpbnN0YW5jZS5fd2lsbFVwZGF0ZSgpO1xuICB9KTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuZnVuY3Rpb24gdXNlVmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBvYnNlcnZlRWxlbWVudFJlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQsXG4gICAgc2Nyb2xsVG9GbjogZWxlbWVudFNjcm9sbCxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuZnVuY3Rpb24gdXNlV2luZG93VmlydHVhbGl6ZXIob3B0aW9ucykge1xuICByZXR1cm4gdXNlVmlydHVhbGl6ZXJCYXNlKHtcbiAgICBnZXRTY3JvbGxFbGVtZW50OiAoKSA9PiB0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiBudWxsLFxuICAgIG9ic2VydmVFbGVtZW50UmVjdDogb2JzZXJ2ZVdpbmRvd1JlY3QsXG4gICAgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQ6IG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gICAgc2Nyb2xsVG9Gbjogd2luZG93U2Nyb2xsLFxuICAgIGluaXRpYWxPZmZzZXQ6ICgpID0+IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5zY3JvbGxZIDogMCxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xufVxuZXhwb3J0IHtcbiAgdXNlVmlydHVhbGl6ZXIsXG4gIHVzZVdpbmRvd1ZpcnR1YWxpemVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiUmVhY3QiLCJmbHVzaFN5bmMiLCJWaXJ0dWFsaXplciIsImVsZW1lbnRTY3JvbGwiLCJvYnNlcnZlRWxlbWVudE9mZnNldCIsIm9ic2VydmVFbGVtZW50UmVjdCIsIndpbmRvd1Njcm9sbCIsIm9ic2VydmVXaW5kb3dPZmZzZXQiLCJvYnNlcnZlV2luZG93UmVjdCIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJkb2N1bWVudCIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVZpcnR1YWxpemVyQmFzZSIsIm9wdGlvbnMiLCJyZXJlbmRlciIsInVzZVJlZHVjZXIiLCJyZXNvbHZlZE9wdGlvbnMiLCJvbkNoYW5nZSIsImluc3RhbmNlMiIsInN5bmMiLCJfYSIsImNhbGwiLCJpbnN0YW5jZSIsInVzZVN0YXRlIiwic2V0T3B0aW9ucyIsIl9kaWRNb3VudCIsIl93aWxsVXBkYXRlIiwidXNlVmlydHVhbGl6ZXIiLCJzY3JvbGxUb0ZuIiwidXNlV2luZG93VmlydHVhbGl6ZXIiLCJnZXRTY3JvbGxFbGVtZW50Iiwid2luZG93IiwiaW5pdGlhbE9mZnNldCIsInNjcm9sbFkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/react-virtual/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Virtualizer: () => (/* binding */ Virtualizer),\n/* harmony export */   approxEqual: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual),\n/* harmony export */   debounce: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defaultKeyExtractor: () => (/* binding */ defaultKeyExtractor),\n/* harmony export */   defaultRangeExtractor: () => (/* binding */ defaultRangeExtractor),\n/* harmony export */   elementScroll: () => (/* binding */ elementScroll),\n/* harmony export */   measureElement: () => (/* binding */ measureElement),\n/* harmony export */   memo: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.memo),\n/* harmony export */   notUndefined: () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined),\n/* harmony export */   observeElementOffset: () => (/* binding */ observeElementOffset),\n/* harmony export */   observeElementRect: () => (/* binding */ observeElementRect),\n/* harmony export */   observeWindowOffset: () => (/* binding */ observeWindowOffset),\n/* harmony export */   observeWindowRect: () => (/* binding */ observeWindowRect),\n/* harmony export */   windowScroll: () => (/* binding */ windowScroll)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\");\n\nconst defaultKeyExtractor = (index)=>index;\nconst defaultRangeExtractor = (range)=>{\n    const start = Math.max(range.startIndex - range.overscan, 0);\n    const end = Math.min(range.endIndex + range.overscan, range.count - 1);\n    const arr = [];\n    for(let i = start; i <= end; i++){\n        arr.push(i);\n    }\n    return arr;\n};\nconst observeElementRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    const handler = (rect)=>{\n        const { width, height } = rect;\n        cb({\n            width: Math.round(width),\n            height: Math.round(height)\n        });\n    };\n    handler(element.getBoundingClientRect());\n    if (!targetWindow.ResizeObserver) {\n        return ()=>{};\n    }\n    const observer = new targetWindow.ResizeObserver((entries)=>{\n        const run = ()=>{\n            const entry = entries[0];\n            if (entry == null ? void 0 : entry.borderBoxSize) {\n                const box = entry.borderBoxSize[0];\n                if (box) {\n                    handler({\n                        width: box.inlineSize,\n                        height: box.blockSize\n                    });\n                    return;\n                }\n            }\n            handler(element.getBoundingClientRect());\n        };\n        instance.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n    });\n    observer.observe(element, {\n        box: \"border-box\"\n    });\n    return ()=>{\n        observer.unobserve(element);\n    };\n};\nconst addEventListenerOptions = {\n    passive: true\n};\nconst observeWindowRect = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const handler = ()=>{\n        cb({\n            width: element.innerWidth,\n            height: element.innerHeight\n        });\n    };\n    handler();\n    element.addEventListener(\"resize\", handler, addEventListenerOptions);\n    return ()=>{\n        element.removeEventListener(\"resize\", handler);\n    };\n};\nconst supportsScrollend =  true ? true : 0;\nconst observeElementOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    let offset = 0;\n    const fallback = instance.options.useScrollendEvent && supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(targetWindow, ()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            const { horizontal, isRtl } = instance.options;\n            offset = horizontal ? element[\"scrollLeft\"] * (isRtl && -1 || 1) : element[\"scrollTop\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n    if (registerScrollendEvent) {\n        element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    }\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        if (registerScrollendEvent) {\n            element.removeEventListener(\"scrollend\", endHandler);\n        }\n    };\n};\nconst observeWindowOffset = (instance, cb)=>{\n    const element = instance.scrollElement;\n    if (!element) {\n        return;\n    }\n    const targetWindow = instance.targetWindow;\n    if (!targetWindow) {\n        return;\n    }\n    let offset = 0;\n    const fallback = instance.options.useScrollendEvent && supportsScrollend ? ()=>void 0 : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.debounce)(targetWindow, ()=>{\n        cb(offset, false);\n    }, instance.options.isScrollingResetDelay);\n    const createHandler = (isScrolling)=>()=>{\n            offset = element[instance.options.horizontal ? \"scrollX\" : \"scrollY\"];\n            fallback();\n            cb(offset, isScrolling);\n        };\n    const handler = createHandler(true);\n    const endHandler = createHandler(false);\n    endHandler();\n    element.addEventListener(\"scroll\", handler, addEventListenerOptions);\n    const registerScrollendEvent = instance.options.useScrollendEvent && supportsScrollend;\n    if (registerScrollendEvent) {\n        element.addEventListener(\"scrollend\", endHandler, addEventListenerOptions);\n    }\n    return ()=>{\n        element.removeEventListener(\"scroll\", handler);\n        if (registerScrollendEvent) {\n            element.removeEventListener(\"scrollend\", endHandler);\n        }\n    };\n};\nconst measureElement = (element, entry, instance)=>{\n    if (entry == null ? void 0 : entry.borderBoxSize) {\n        const box = entry.borderBoxSize[0];\n        if (box) {\n            const size = Math.round(box[instance.options.horizontal ? \"inlineSize\" : \"blockSize\"]);\n            return size;\n        }\n    }\n    return Math.round(element.getBoundingClientRect()[instance.options.horizontal ? \"width\" : \"height\"]);\n};\nconst windowScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nconst elementScroll = (offset, { adjustments = 0, behavior }, instance)=>{\n    var _a, _b;\n    const toOffset = offset + adjustments;\n    (_b = (_a = instance.scrollElement) == null ? void 0 : _a.scrollTo) == null ? void 0 : _b.call(_a, {\n        [instance.options.horizontal ? \"left\" : \"top\"]: toOffset,\n        behavior\n    });\n};\nclass Virtualizer {\n    constructor(opts){\n        this.unsubs = [];\n        this.scrollElement = null;\n        this.targetWindow = null;\n        this.isScrolling = false;\n        this.scrollToIndexTimeoutId = null;\n        this.measurementsCache = [];\n        this.itemSizeCache = /* @__PURE__ */ new Map();\n        this.pendingMeasuredCacheIndexes = [];\n        this.scrollRect = null;\n        this.scrollOffset = null;\n        this.scrollDirection = null;\n        this.scrollAdjustments = 0;\n        this.elementsCache = /* @__PURE__ */ new Map();\n        this.observer = /* @__PURE__ */ (()=>{\n            let _ro = null;\n            const get = ()=>{\n                if (_ro) {\n                    return _ro;\n                }\n                if (!this.targetWindow || !this.targetWindow.ResizeObserver) {\n                    return null;\n                }\n                return _ro = new this.targetWindow.ResizeObserver((entries)=>{\n                    entries.forEach((entry)=>{\n                        const run = ()=>{\n                            this._measureElement(entry.target, entry);\n                        };\n                        this.options.useAnimationFrameWithResizeObserver ? requestAnimationFrame(run) : run();\n                    });\n                });\n            };\n            return {\n                disconnect: ()=>{\n                    var _a;\n                    (_a = get()) == null ? void 0 : _a.disconnect();\n                    _ro = null;\n                },\n                observe: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.observe(target, {\n                        box: \"border-box\"\n                    });\n                },\n                unobserve: (target)=>{\n                    var _a;\n                    return (_a = get()) == null ? void 0 : _a.unobserve(target);\n                }\n            };\n        })();\n        this.range = null;\n        this.setOptions = (opts2)=>{\n            Object.entries(opts2).forEach(([key, value])=>{\n                if (typeof value === \"undefined\") delete opts2[key];\n            });\n            this.options = {\n                debug: false,\n                initialOffset: 0,\n                overscan: 1,\n                paddingStart: 0,\n                paddingEnd: 0,\n                scrollPaddingStart: 0,\n                scrollPaddingEnd: 0,\n                horizontal: false,\n                getItemKey: defaultKeyExtractor,\n                rangeExtractor: defaultRangeExtractor,\n                onChange: ()=>{},\n                measureElement,\n                initialRect: {\n                    width: 0,\n                    height: 0\n                },\n                scrollMargin: 0,\n                gap: 0,\n                indexAttribute: \"data-index\",\n                initialMeasurementsCache: [],\n                lanes: 1,\n                isScrollingResetDelay: 150,\n                enabled: true,\n                isRtl: false,\n                useScrollendEvent: false,\n                useAnimationFrameWithResizeObserver: false,\n                ...opts2\n            };\n        };\n        this.notify = (sync)=>{\n            var _a, _b;\n            (_b = (_a = this.options).onChange) == null ? void 0 : _b.call(_a, this, sync);\n        };\n        this.maybeNotify = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>{\n            this.calculateRange();\n            return [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ];\n        }, (isScrolling)=>{\n            this.notify(isScrolling);\n        }, {\n            key:  true && \"maybeNotify\",\n            debug: ()=>this.options.debug,\n            initialDeps: [\n                this.isScrolling,\n                this.range ? this.range.startIndex : null,\n                this.range ? this.range.endIndex : null\n            ]\n        });\n        this.cleanup = ()=>{\n            this.unsubs.filter(Boolean).forEach((d)=>d());\n            this.unsubs = [];\n            this.observer.disconnect();\n            this.scrollElement = null;\n            this.targetWindow = null;\n        };\n        this._didMount = ()=>{\n            return ()=>{\n                this.cleanup();\n            };\n        };\n        this._willUpdate = ()=>{\n            var _a;\n            const scrollElement = this.options.enabled ? this.options.getScrollElement() : null;\n            if (this.scrollElement !== scrollElement) {\n                this.cleanup();\n                if (!scrollElement) {\n                    this.maybeNotify();\n                    return;\n                }\n                this.scrollElement = scrollElement;\n                if (this.scrollElement && \"ownerDocument\" in this.scrollElement) {\n                    this.targetWindow = this.scrollElement.ownerDocument.defaultView;\n                } else {\n                    this.targetWindow = ((_a = this.scrollElement) == null ? void 0 : _a.window) ?? null;\n                }\n                this.elementsCache.forEach((cached)=>{\n                    this.observer.observe(cached);\n                });\n                this._scrollToOffset(this.getScrollOffset(), {\n                    adjustments: void 0,\n                    behavior: void 0\n                });\n                this.unsubs.push(this.options.observeElementRect(this, (rect)=>{\n                    this.scrollRect = rect;\n                    this.maybeNotify();\n                }));\n                this.unsubs.push(this.options.observeElementOffset(this, (offset, isScrolling)=>{\n                    this.scrollAdjustments = 0;\n                    this.scrollDirection = isScrolling ? this.getScrollOffset() < offset ? \"forward\" : \"backward\" : null;\n                    this.scrollOffset = offset;\n                    this.isScrolling = isScrolling;\n                    this.maybeNotify();\n                }));\n            }\n        };\n        this.getSize = ()=>{\n            if (!this.options.enabled) {\n                this.scrollRect = null;\n                return 0;\n            }\n            this.scrollRect = this.scrollRect ?? this.options.initialRect;\n            return this.scrollRect[this.options.horizontal ? \"width\" : \"height\"];\n        };\n        this.getScrollOffset = ()=>{\n            if (!this.options.enabled) {\n                this.scrollOffset = null;\n                return 0;\n            }\n            this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset === \"function\" ? this.options.initialOffset() : this.options.initialOffset);\n            return this.scrollOffset;\n        };\n        this.getFurthestMeasurement = (measurements, index)=>{\n            const furthestMeasurementsFound = /* @__PURE__ */ new Map();\n            const furthestMeasurements = /* @__PURE__ */ new Map();\n            for(let m = index - 1; m >= 0; m--){\n                const measurement = measurements[m];\n                if (furthestMeasurementsFound.has(measurement.lane)) {\n                    continue;\n                }\n                const previousFurthestMeasurement = furthestMeasurements.get(measurement.lane);\n                if (previousFurthestMeasurement == null || measurement.end > previousFurthestMeasurement.end) {\n                    furthestMeasurements.set(measurement.lane, measurement);\n                } else if (measurement.end < previousFurthestMeasurement.end) {\n                    furthestMeasurementsFound.set(measurement.lane, true);\n                }\n                if (furthestMeasurementsFound.size === this.options.lanes) {\n                    break;\n                }\n            }\n            return furthestMeasurements.size === this.options.lanes ? Array.from(furthestMeasurements.values()).sort((a, b)=>{\n                if (a.end === b.end) {\n                    return a.index - b.index;\n                }\n                return a.end - b.end;\n            })[0] : void 0;\n        };\n        this.getMeasurementOptions = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.options.count,\n                this.options.paddingStart,\n                this.options.scrollMargin,\n                this.options.getItemKey,\n                this.options.enabled\n            ], (count, paddingStart, scrollMargin, getItemKey, enabled)=>{\n            this.pendingMeasuredCacheIndexes = [];\n            return {\n                count,\n                paddingStart,\n                scrollMargin,\n                getItemKey,\n                enabled\n            };\n        }, {\n            key: false\n        });\n        this.getMeasurements = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurementOptions(),\n                this.itemSizeCache\n            ], ({ count, paddingStart, scrollMargin, getItemKey, enabled }, itemSizeCache)=>{\n            if (!enabled) {\n                this.measurementsCache = [];\n                this.itemSizeCache.clear();\n                return [];\n            }\n            if (this.measurementsCache.length === 0) {\n                this.measurementsCache = this.options.initialMeasurementsCache;\n                this.measurementsCache.forEach((item)=>{\n                    this.itemSizeCache.set(item.key, item.size);\n                });\n            }\n            const min = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;\n            this.pendingMeasuredCacheIndexes = [];\n            const measurements = this.measurementsCache.slice(0, min);\n            for(let i = min; i < count; i++){\n                const key = getItemKey(i);\n                const furthestMeasurement = this.options.lanes === 1 ? measurements[i - 1] : this.getFurthestMeasurement(measurements, i);\n                const start = furthestMeasurement ? furthestMeasurement.end + this.options.gap : paddingStart + scrollMargin;\n                const measuredSize = itemSizeCache.get(key);\n                const size = typeof measuredSize === \"number\" ? measuredSize : this.options.estimateSize(i);\n                const end = start + size;\n                const lane = furthestMeasurement ? furthestMeasurement.lane : i % this.options.lanes;\n                measurements[i] = {\n                    index: i,\n                    start,\n                    size,\n                    end,\n                    key,\n                    lane\n                };\n            }\n            this.measurementsCache = measurements;\n            return measurements;\n        }, {\n            key:  true && \"getMeasurements\",\n            debug: ()=>this.options.debug\n        });\n        this.calculateRange = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getMeasurements(),\n                this.getSize(),\n                this.getScrollOffset(),\n                this.options.lanes\n            ], (measurements, outerSize, scrollOffset, lanes)=>{\n            return this.range = measurements.length > 0 && outerSize > 0 ? calculateRange({\n                measurements,\n                outerSize,\n                scrollOffset,\n                lanes\n            }) : null;\n        }, {\n            key:  true && \"calculateRange\",\n            debug: ()=>this.options.debug\n        });\n        this.getVirtualIndexes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>{\n            let startIndex = null;\n            let endIndex = null;\n            const range = this.calculateRange();\n            if (range) {\n                startIndex = range.startIndex;\n                endIndex = range.endIndex;\n            }\n            this.maybeNotify.updateDeps([\n                this.isScrolling,\n                startIndex,\n                endIndex\n            ]);\n            return [\n                this.options.rangeExtractor,\n                this.options.overscan,\n                this.options.count,\n                startIndex,\n                endIndex\n            ];\n        }, (rangeExtractor, overscan, count, startIndex, endIndex)=>{\n            return startIndex === null || endIndex === null ? [] : rangeExtractor({\n                startIndex,\n                endIndex,\n                overscan,\n                count\n            });\n        }, {\n            key:  true && \"getVirtualIndexes\",\n            debug: ()=>this.options.debug\n        });\n        this.indexFromElement = (node)=>{\n            const attributeName = this.options.indexAttribute;\n            const indexStr = node.getAttribute(attributeName);\n            if (!indexStr) {\n                console.warn(`Missing attribute name '${attributeName}={index}' on measured element.`);\n                return -1;\n            }\n            return parseInt(indexStr, 10);\n        };\n        this._measureElement = (node, entry)=>{\n            const index = this.indexFromElement(node);\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return;\n            }\n            const key = item.key;\n            const prevNode = this.elementsCache.get(key);\n            if (prevNode !== node) {\n                if (prevNode) {\n                    this.observer.unobserve(prevNode);\n                }\n                this.observer.observe(node);\n                this.elementsCache.set(key, node);\n            }\n            if (node.isConnected) {\n                this.resizeItem(index, this.options.measureElement(node, entry, this));\n            }\n        };\n        this.resizeItem = (index, size)=>{\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return;\n            }\n            const itemSize = this.itemSizeCache.get(item.key) ?? item.size;\n            const delta = size - itemSize;\n            if (delta !== 0) {\n                if (this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(item, delta, this) : item.start < this.getScrollOffset() + this.scrollAdjustments) {\n                    if ( true && this.options.debug) {\n                        console.info(\"correction\", delta);\n                    }\n                    this._scrollToOffset(this.getScrollOffset(), {\n                        adjustments: this.scrollAdjustments += delta,\n                        behavior: void 0\n                    });\n                }\n                this.pendingMeasuredCacheIndexes.push(item.index);\n                this.itemSizeCache = new Map(this.itemSizeCache.set(item.key, size));\n                this.notify(false);\n            }\n        };\n        this.measureElement = (node)=>{\n            if (!node) {\n                this.elementsCache.forEach((cached, key)=>{\n                    if (!cached.isConnected) {\n                        this.observer.unobserve(cached);\n                        this.elementsCache.delete(key);\n                    }\n                });\n                return;\n            }\n            this._measureElement(node, void 0);\n        };\n        this.getVirtualItems = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memo)(()=>[\n                this.getVirtualIndexes(),\n                this.getMeasurements()\n            ], (indexes, measurements)=>{\n            const virtualItems = [];\n            for(let k = 0, len = indexes.length; k < len; k++){\n                const i = indexes[k];\n                const measurement = measurements[i];\n                virtualItems.push(measurement);\n            }\n            return virtualItems;\n        }, {\n            key:  true && \"getVirtualItems\",\n            debug: ()=>this.options.debug\n        });\n        this.getVirtualItemForOffset = (offset)=>{\n            const measurements = this.getMeasurements();\n            if (measurements.length === 0) {\n                return void 0;\n            }\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[findNearestBinarySearch(0, measurements.length - 1, (index)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(measurements[index]).start, offset)]);\n        };\n        this.getOffsetForAlignment = (toOffset, align, itemSize = 0)=>{\n            const size = this.getSize();\n            const scrollOffset = this.getScrollOffset();\n            if (align === \"auto\") {\n                align = toOffset >= scrollOffset + size ? \"end\" : \"start\";\n            }\n            if (align === \"center\") {\n                toOffset += (itemSize - size) / 2;\n            } else if (align === \"end\") {\n                toOffset -= size;\n            }\n            const scrollSizeProp = this.options.horizontal ? \"scrollWidth\" : \"scrollHeight\";\n            const scrollSize = this.scrollElement ? \"document\" in this.scrollElement ? this.scrollElement.document.documentElement[scrollSizeProp] : this.scrollElement[scrollSizeProp] : 0;\n            const maxOffset = scrollSize - size;\n            return Math.max(Math.min(maxOffset, toOffset), 0);\n        };\n        this.getOffsetForIndex = (index, align = \"auto\")=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            const item = this.measurementsCache[index];\n            if (!item) {\n                return void 0;\n            }\n            const size = this.getSize();\n            const scrollOffset = this.getScrollOffset();\n            if (align === \"auto\") {\n                if (item.end >= scrollOffset + size - this.options.scrollPaddingEnd) {\n                    align = \"end\";\n                } else if (item.start <= scrollOffset + this.options.scrollPaddingStart) {\n                    align = \"start\";\n                } else {\n                    return [\n                        scrollOffset,\n                        align\n                    ];\n                }\n            }\n            const toOffset = align === \"end\" ? item.end + this.options.scrollPaddingEnd : item.start - this.options.scrollPaddingStart;\n            return [\n                this.getOffsetForAlignment(toOffset, align, item.size),\n                align\n            ];\n        };\n        this.isDynamicMode = ()=>this.elementsCache.size > 0;\n        this.cancelScrollToIndex = ()=>{\n            if (this.scrollToIndexTimeoutId !== null && this.targetWindow) {\n                this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId);\n                this.scrollToIndexTimeoutId = null;\n            }\n        };\n        this.scrollToOffset = (toOffset, { align = \"start\", behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getOffsetForAlignment(toOffset, align), {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.scrollToIndex = (index, { align: initialAlign = \"auto\", behavior } = {})=>{\n            index = Math.max(0, Math.min(index, this.options.count - 1));\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            const offsetAndAlign = this.getOffsetForIndex(index, initialAlign);\n            if (!offsetAndAlign) return;\n            const [offset, align] = offsetAndAlign;\n            this._scrollToOffset(offset, {\n                adjustments: void 0,\n                behavior\n            });\n            if (behavior !== \"smooth\" && this.isDynamicMode() && this.targetWindow) {\n                this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(()=>{\n                    this.scrollToIndexTimeoutId = null;\n                    const elementInDOM = this.elementsCache.has(this.options.getItemKey(index));\n                    if (elementInDOM) {\n                        const [latestOffset] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notUndefined)(this.getOffsetForIndex(index, align));\n                        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.approxEqual)(latestOffset, this.getScrollOffset())) {\n                            this.scrollToIndex(index, {\n                                align,\n                                behavior\n                            });\n                        }\n                    } else {\n                        this.scrollToIndex(index, {\n                            align,\n                            behavior\n                        });\n                    }\n                });\n            }\n        };\n        this.scrollBy = (delta, { behavior } = {})=>{\n            this.cancelScrollToIndex();\n            if (behavior === \"smooth\" && this.isDynamicMode()) {\n                console.warn(\"The `smooth` scroll behavior is not fully supported with dynamic size.\");\n            }\n            this._scrollToOffset(this.getScrollOffset() + delta, {\n                adjustments: void 0,\n                behavior\n            });\n        };\n        this.getTotalSize = ()=>{\n            var _a;\n            const measurements = this.getMeasurements();\n            let end;\n            if (measurements.length === 0) {\n                end = this.options.paddingStart;\n            } else if (this.options.lanes === 1) {\n                end = ((_a = measurements[measurements.length - 1]) == null ? void 0 : _a.end) ?? 0;\n            } else {\n                const endByLane = Array(this.options.lanes).fill(null);\n                let endIndex = measurements.length - 1;\n                while(endIndex > 0 && endByLane.some((val)=>val === null)){\n                    const item = measurements[endIndex];\n                    if (endByLane[item.lane] === null) {\n                        endByLane[item.lane] = item.end;\n                    }\n                    endIndex--;\n                }\n                end = Math.max(...endByLane.filter((val)=>val !== null));\n            }\n            return Math.max(end - this.options.scrollMargin + this.options.paddingEnd, 0);\n        };\n        this._scrollToOffset = (offset, { adjustments, behavior })=>{\n            this.options.scrollToFn(offset, {\n                behavior,\n                adjustments\n            }, this);\n        };\n        this.measure = ()=>{\n            this.itemSizeCache = /* @__PURE__ */ new Map();\n            this.notify(false);\n        };\n        this.setOptions(opts);\n    }\n}\nconst findNearestBinarySearch = (low, high, getCurrentValue, value)=>{\n    while(low <= high){\n        const middle = (low + high) / 2 | 0;\n        const currentValue = getCurrentValue(middle);\n        if (currentValue < value) {\n            low = middle + 1;\n        } else if (currentValue > value) {\n            high = middle - 1;\n        } else {\n            return middle;\n        }\n    }\n    if (low > 0) {\n        return low - 1;\n    } else {\n        return 0;\n    }\n};\nfunction calculateRange({ measurements, outerSize, scrollOffset, lanes }) {\n    const lastIndex = measurements.length - 1;\n    const getOffset = (index)=>measurements[index].start;\n    let startIndex = findNearestBinarySearch(0, lastIndex, getOffset, scrollOffset);\n    let endIndex = startIndex;\n    if (lanes === 1) {\n        while(endIndex < lastIndex && measurements[endIndex].end < scrollOffset + outerSize){\n            endIndex++;\n        }\n    } else if (lanes > 1) {\n        const endPerLane = Array(lanes).fill(0);\n        while(endIndex < lastIndex && endPerLane.some((pos)=>pos < scrollOffset + outerSize)){\n            const item = measurements[endIndex];\n            endPerLane[item.lane] = item.end;\n            endIndex++;\n        }\n        const startPerLane = Array(lanes).fill(scrollOffset + outerSize);\n        while(startIndex > 0 && startPerLane.some((pos)=>pos >= scrollOffset)){\n            const item = measurements[startIndex];\n            startPerLane[item.lane] = item.start;\n            startIndex--;\n        }\n        startIndex = Math.max(0, startIndex - startIndex % lanes);\n        endIndex = Math.min(lastIndex, endIndex + (lanes - 1 - endIndex % lanes));\n    }\n    return {\n        startIndex,\n        endIndex\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUU7QUFDdkUsTUFBTUksc0JBQXNCLENBQUNDLFFBQVVBO0FBQ3ZDLE1BQU1DLHdCQUF3QixDQUFDQztJQUM3QixNQUFNQyxRQUFRQyxLQUFLQyxHQUFHLENBQUNILE1BQU1JLFVBQVUsR0FBR0osTUFBTUssUUFBUSxFQUFFO0lBQzFELE1BQU1DLE1BQU1KLEtBQUtLLEdBQUcsQ0FBQ1AsTUFBTVEsUUFBUSxHQUFHUixNQUFNSyxRQUFRLEVBQUVMLE1BQU1TLEtBQUssR0FBRztJQUNwRSxNQUFNQyxNQUFNLEVBQUU7SUFDZCxJQUFLLElBQUlDLElBQUlWLE9BQU9VLEtBQUtMLEtBQUtLLElBQUs7UUFDakNELElBQUlFLElBQUksQ0FBQ0Q7SUFDWDtJQUNBLE9BQU9EO0FBQ1Q7QUFDQSxNQUFNRyxxQkFBcUIsQ0FBQ0MsVUFBVUM7SUFDcEMsTUFBTUMsVUFBVUYsU0FBU0csYUFBYTtJQUN0QyxJQUFJLENBQUNELFNBQVM7UUFDWjtJQUNGO0lBQ0EsTUFBTUUsZUFBZUosU0FBU0ksWUFBWTtJQUMxQyxJQUFJLENBQUNBLGNBQWM7UUFDakI7SUFDRjtJQUNBLE1BQU1DLFVBQVUsQ0FBQ0M7UUFDZixNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFLEdBQUdGO1FBQzFCTCxHQUFHO1lBQUVNLE9BQU9uQixLQUFLcUIsS0FBSyxDQUFDRjtZQUFRQyxRQUFRcEIsS0FBS3FCLEtBQUssQ0FBQ0Q7UUFBUTtJQUM1RDtJQUNBSCxRQUFRSCxRQUFRUSxxQkFBcUI7SUFDckMsSUFBSSxDQUFDTixhQUFhTyxjQUFjLEVBQUU7UUFDaEMsT0FBTyxLQUNQO0lBQ0Y7SUFDQSxNQUFNQyxXQUFXLElBQUlSLGFBQWFPLGNBQWMsQ0FBQyxDQUFDRTtRQUNoRCxNQUFNQyxNQUFNO1lBQ1YsTUFBTUMsUUFBUUYs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bEUsS0FBS2IsSUFBSSxDQUFDLEdBQUdhLEtBQUt0SixLQUFLO1lBQ3BDRztRQUNGO1FBQ0FBLGFBQWFGLEtBQUtDLEdBQUcsQ0FBQyxHQUFHQyxhQUFhQSxhQUFhMEc7UUFDbkR0RyxXQUFXTixLQUFLSyxHQUFHLENBQUM4TSxXQUFXN00sV0FBWXNHLENBQUFBLFFBQVEsSUFBSXRHLFdBQVdzRyxLQUFJO0lBQ3hFO0lBQ0EsT0FBTztRQUFFMUc7UUFBWUk7SUFBUztBQUNoQztBQWdCRSxDQUNGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xlLW1vbmRlLXN1Y3JlLWRlLWxpbmRhLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0YW5zdGFjay92aXJ0dWFsLWNvcmUvZGlzdC9lc20vaW5kZXguanM/YjY5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZWJvdW5jZSwgbWVtbywgbm90VW5kZWZpbmVkLCBhcHByb3hFcXVhbCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5jb25zdCBkZWZhdWx0S2V5RXh0cmFjdG9yID0gKGluZGV4KSA9PiBpbmRleDtcbmNvbnN0IGRlZmF1bHRSYW5nZUV4dHJhY3RvciA9IChyYW5nZSkgPT4ge1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHJhbmdlLnN0YXJ0SW5kZXggLSByYW5nZS5vdmVyc2NhbiwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHJhbmdlLmVuZEluZGV4ICsgcmFuZ2Uub3ZlcnNjYW4sIHJhbmdlLmNvdW50IC0gMSk7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gZW5kOyBpKyspIHtcbiAgICBhcnIucHVzaChpKTtcbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbmNvbnN0IG9ic2VydmVFbGVtZW50UmVjdCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhbmRsZXIgPSAocmVjdCkgPT4ge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVjdDtcbiAgICBjYih7IHdpZHRoOiBNYXRoLnJvdW5kKHdpZHRoKSwgaGVpZ2h0OiBNYXRoLnJvdW5kKGhlaWdodCkgfSk7XG4gIH07XG4gIGhhbmRsZXIoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gIGlmICghdGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICB9O1xuICB9XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IHRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICAgIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgICAgICBjb25zdCBib3ggPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgaGFuZGxlcih7IHdpZHRoOiBib3guaW5saW5lU2l6ZSwgaGVpZ2h0OiBib3guYmxvY2tTaXplIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaGFuZGxlcihlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICB9O1xuICAgIGluc3RhbmNlLm9wdGlvbnMudXNlQW5pbWF0aW9uRnJhbWVXaXRoUmVzaXplT2JzZXJ2ZXIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocnVuKSA6IHJ1bigpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9O1xufTtcbmNvbnN0IGFkZEV2ZW50TGlzdGVuZXJPcHRpb25zID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd1JlY3QgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICBjYih7IHdpZHRoOiBlbGVtZW50LmlubmVyV2lkdGgsIGhlaWdodDogZWxlbWVudC5pbm5lckhlaWdodCB9KTtcbiAgfTtcbiAgaGFuZGxlcigpO1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlciwgYWRkRXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVyKTtcbiAgfTtcbn07XG5jb25zdCBzdXBwb3J0c1Njcm9sbGVuZCA9IHR5cGVvZiB3aW5kb3cgPT0gXCJ1bmRlZmluZWRcIiA/IHRydWUgOiBcIm9uc2Nyb2xsZW5kXCIgaW4gd2luZG93O1xuY29uc3Qgb2JzZXJ2ZUVsZW1lbnRPZmZzZXQgPSAoaW5zdGFuY2UsIGNiKSA9PiB7XG4gIGNvbnN0IGVsZW1lbnQgPSBpbnN0YW5jZS5zY3JvbGxFbGVtZW50O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdGFyZ2V0V2luZG93ID0gaW5zdGFuY2UudGFyZ2V0V2luZG93O1xuICBpZiAoIXRhcmdldFdpbmRvdykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb2Zmc2V0ID0gMDtcbiAgY29uc3QgZmFsbGJhY2sgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kID8gKCkgPT4gdm9pZCAwIDogZGVib3VuY2UoXG4gICAgdGFyZ2V0V2luZG93LFxuICAgICgpID0+IHtcbiAgICAgIGNiKG9mZnNldCwgZmFsc2UpO1xuICAgIH0sXG4gICAgaW5zdGFuY2Uub3B0aW9ucy5pc1Njcm9sbGluZ1Jlc2V0RGVsYXlcbiAgKTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlciA9IChpc1Njcm9sbGluZykgPT4gKCkgPT4ge1xuICAgIGNvbnN0IHsgaG9yaXpvbnRhbCwgaXNSdGwgfSA9IGluc3RhbmNlLm9wdGlvbnM7XG4gICAgb2Zmc2V0ID0gaG9yaXpvbnRhbCA/IGVsZW1lbnRbXCJzY3JvbGxMZWZ0XCJdICogKGlzUnRsICYmIC0xIHx8IDEpIDogZWxlbWVudFtcInNjcm9sbFRvcFwiXTtcbiAgICBmYWxsYmFjaygpO1xuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVyID0gY3JlYXRlSGFuZGxlcih0cnVlKTtcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpO1xuICBlbmRIYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kO1xuICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICB9XG4gIH07XG59O1xuY29uc3Qgb2JzZXJ2ZVdpbmRvd09mZnNldCA9IChpbnN0YW5jZSwgY2IpID0+IHtcbiAgY29uc3QgZWxlbWVudCA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQ7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0YXJnZXRXaW5kb3cgPSBpbnN0YW5jZS50YXJnZXRXaW5kb3c7XG4gIGlmICghdGFyZ2V0V2luZG93KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvZmZzZXQgPSAwO1xuICBjb25zdCBmYWxsYmFjayA9IGluc3RhbmNlLm9wdGlvbnMudXNlU2Nyb2xsZW5kRXZlbnQgJiYgc3VwcG9ydHNTY3JvbGxlbmQgPyAoKSA9PiB2b2lkIDAgOiBkZWJvdW5jZShcbiAgICB0YXJnZXRXaW5kb3csXG4gICAgKCkgPT4ge1xuICAgICAgY2Iob2Zmc2V0LCBmYWxzZSk7XG4gICAgfSxcbiAgICBpbnN0YW5jZS5vcHRpb25zLmlzU2Nyb2xsaW5nUmVzZXREZWxheVxuICApO1xuICBjb25zdCBjcmVhdGVIYW5kbGVyID0gKGlzU2Nyb2xsaW5nKSA9PiAoKSA9PiB7XG4gICAgb2Zmc2V0ID0gZWxlbWVudFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbFhcIiA6IFwic2Nyb2xsWVwiXTtcbiAgICBmYWxsYmFjaygpO1xuICAgIGNiKG9mZnNldCwgaXNTY3JvbGxpbmcpO1xuICB9O1xuICBjb25zdCBoYW5kbGVyID0gY3JlYXRlSGFuZGxlcih0cnVlKTtcbiAgY29uc3QgZW5kSGFuZGxlciA9IGNyZWF0ZUhhbmRsZXIoZmFsc2UpO1xuICBlbmRIYW5kbGVyKCk7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBoYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIGNvbnN0IHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQgPSBpbnN0YW5jZS5vcHRpb25zLnVzZVNjcm9sbGVuZEV2ZW50ICYmIHN1cHBvcnRzU2Nyb2xsZW5kO1xuICBpZiAocmVnaXN0ZXJTY3JvbGxlbmRFdmVudCkge1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyLCBhZGRFdmVudExpc3RlbmVyT3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgaGFuZGxlcik7XG4gICAgaWYgKHJlZ2lzdGVyU2Nyb2xsZW5kRXZlbnQpIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbGVuZFwiLCBlbmRIYW5kbGVyKTtcbiAgICB9XG4gIH07XG59O1xuY29uc3QgbWVhc3VyZUVsZW1lbnQgPSAoZWxlbWVudCwgZW50cnksIGluc3RhbmNlKSA9PiB7XG4gIGlmIChlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuYm9yZGVyQm94U2l6ZSkge1xuICAgIGNvbnN0IGJveCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF07XG4gICAgaWYgKGJveCkge1xuICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgucm91bmQoXG4gICAgICAgIGJveFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImlubGluZVNpemVcIiA6IFwiYmxvY2tTaXplXCJdXG4gICAgICApO1xuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLnJvdW5kKFxuICAgIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl1cbiAgKTtcbn07XG5jb25zdCB3aW5kb3dTY3JvbGwgPSAob2Zmc2V0LCB7XG4gIGFkanVzdG1lbnRzID0gMCxcbiAgYmVoYXZpb3Jcbn0sIGluc3RhbmNlKSA9PiB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHRvT2Zmc2V0ID0gb2Zmc2V0ICsgYWRqdXN0bWVudHM7XG4gIChfYiA9IChfYSA9IGluc3RhbmNlLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zY3JvbGxUbykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICBbaW5zdGFuY2Uub3B0aW9ucy5ob3Jpem9udGFsID8gXCJsZWZ0XCIgOiBcInRvcFwiXTogdG9PZmZzZXQsXG4gICAgYmVoYXZpb3JcbiAgfSk7XG59O1xuY29uc3QgZWxlbWVudFNjcm9sbCA9IChvZmZzZXQsIHtcbiAgYWRqdXN0bWVudHMgPSAwLFxuICBiZWhhdmlvclxufSwgaW5zdGFuY2UpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgdG9PZmZzZXQgPSBvZmZzZXQgKyBhZGp1c3RtZW50cztcbiAgKF9iID0gKF9hID0gaW5zdGFuY2Uuc2Nyb2xsRWxlbWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnNjcm9sbFRvKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgIFtpbnN0YW5jZS5vcHRpb25zLmhvcml6b250YWwgPyBcImxlZnRcIiA6IFwidG9wXCJdOiB0b09mZnNldCxcbiAgICBiZWhhdmlvclxuICB9KTtcbn07XG5jbGFzcyBWaXJ0dWFsaXplciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy50YXJnZXRXaW5kb3cgPSBudWxsO1xuICAgIHRoaXMuaXNTY3JvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBbXTtcbiAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzID0gW107XG4gICAgdGhpcy5zY3JvbGxSZWN0ID0gbnVsbDtcbiAgICB0aGlzLnNjcm9sbE9mZnNldCA9IG51bGw7XG4gICAgdGhpcy5zY3JvbGxEaXJlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuc2Nyb2xsQWRqdXN0bWVudHMgPSAwO1xuICAgIHRoaXMuZWxlbWVudHNDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5vYnNlcnZlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgICAgbGV0IF9ybyA9IG51bGw7XG4gICAgICBjb25zdCBnZXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChfcm8pIHtcbiAgICAgICAgICByZXR1cm4gX3JvO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy50YXJnZXRXaW5kb3cgfHwgIXRoaXMudGFyZ2V0V2luZG93LlJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9ybyA9IG5ldyB0aGlzLnRhcmdldFdpbmRvdy5SZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgIGVudHJpZXMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQoZW50cnkudGFyZ2V0LCBlbnRyeSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJ1bikgOiBydW4oKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzY29ubmVjdDogKCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICBfcm8gPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvYnNlcnZlOiAodGFyZ2V0KSA9PiB7XG4gICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgIHJldHVybiAoX2EgPSBnZXQoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm9ic2VydmUodGFyZ2V0LCB7IGJveDogXCJib3JkZXItYm94XCIgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHVub2JzZXJ2ZTogKHRhcmdldCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICByZXR1cm4gKF9hID0gZ2V0KCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS51bm9ic2VydmUodGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpO1xuICAgIHRoaXMucmFuZ2UgPSBudWxsO1xuICAgIHRoaXMuc2V0T3B0aW9ucyA9IChvcHRzMikgPT4ge1xuICAgICAgT2JqZWN0LmVudHJpZXMob3B0czIpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSBkZWxldGUgb3B0czJba2V5XTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWxPZmZzZXQ6IDAsXG4gICAgICAgIG92ZXJzY2FuOiAxLFxuICAgICAgICBwYWRkaW5nU3RhcnQ6IDAsXG4gICAgICAgIHBhZGRpbmdFbmQ6IDAsXG4gICAgICAgIHNjcm9sbFBhZGRpbmdTdGFydDogMCxcbiAgICAgICAgc2Nyb2xsUGFkZGluZ0VuZDogMCxcbiAgICAgICAgaG9yaXpvbnRhbDogZmFsc2UsXG4gICAgICAgIGdldEl0ZW1LZXk6IGRlZmF1bHRLZXlFeHRyYWN0b3IsXG4gICAgICAgIHJhbmdlRXh0cmFjdG9yOiBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gICAgICAgIG9uQ2hhbmdlOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG1lYXN1cmVFbGVtZW50LFxuICAgICAgICBpbml0aWFsUmVjdDogeyB3aWR0aDogMCwgaGVpZ2h0OiAwIH0sXG4gICAgICAgIHNjcm9sbE1hcmdpbjogMCxcbiAgICAgICAgZ2FwOiAwLFxuICAgICAgICBpbmRleEF0dHJpYnV0ZTogXCJkYXRhLWluZGV4XCIsXG4gICAgICAgIGluaXRpYWxNZWFzdXJlbWVudHNDYWNoZTogW10sXG4gICAgICAgIGxhbmVzOiAxLFxuICAgICAgICBpc1Njcm9sbGluZ1Jlc2V0RGVsYXk6IDE1MCxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgaXNSdGw6IGZhbHNlLFxuICAgICAgICB1c2VTY3JvbGxlbmRFdmVudDogZmFsc2UsXG4gICAgICAgIHVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0czJcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLm5vdGlmeSA9IChzeW5jKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9iID0gKF9hID0gdGhpcy5vcHRpb25zKS5vbkNoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMsIHN5bmMpO1xuICAgIH07XG4gICAgdGhpcy5tYXliZU5vdGlmeSA9IG1lbW8oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLnN0YXJ0SW5kZXggOiBudWxsLFxuICAgICAgICAgIHRoaXMucmFuZ2UgPyB0aGlzLnJhbmdlLmVuZEluZGV4IDogbnVsbFxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIChpc1Njcm9sbGluZykgPT4ge1xuICAgICAgICB0aGlzLm5vdGlmeShpc1Njcm9sbGluZyk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcIm1heWJlTm90aWZ5XCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWcsXG4gICAgICAgIGluaXRpYWxEZXBzOiBbXG4gICAgICAgICAgdGhpcy5pc1Njcm9sbGluZyxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5zdGFydEluZGV4IDogbnVsbCxcbiAgICAgICAgICB0aGlzLnJhbmdlID8gdGhpcy5yYW5nZS5lbmRJbmRleCA6IG51bGxcbiAgICAgICAgXVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5jbGVhbnVwID0gKCkgPT4ge1xuICAgICAgdGhpcy51bnN1YnMuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goKGQpID0+IGQoKSk7XG4gICAgICB0aGlzLnVuc3VicyA9IFtdO1xuICAgICAgdGhpcy5vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSBudWxsO1xuICAgIH07XG4gICAgdGhpcy5fZGlkTW91bnQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICB0aGlzLl93aWxsVXBkYXRlID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qgc2Nyb2xsRWxlbWVudCA9IHRoaXMub3B0aW9ucy5lbmFibGVkID8gdGhpcy5vcHRpb25zLmdldFNjcm9sbEVsZW1lbnQoKSA6IG51bGw7XG4gICAgICBpZiAodGhpcy5zY3JvbGxFbGVtZW50ICE9PSBzY3JvbGxFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICBpZiAoIXNjcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLnNjcm9sbEVsZW1lbnQgJiYgXCJvd25lckRvY3VtZW50XCIgaW4gdGhpcy5zY3JvbGxFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cgPSB0aGlzLnNjcm9sbEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRhcmdldFdpbmRvdyA9ICgoX2EgPSB0aGlzLnNjcm9sbEVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS53aW5kb3cpID8/IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLmZvckVhY2goKGNhY2hlZCkgPT4ge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZShjYWNoZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRTY3JvbGxPZmZzZXQoKSwge1xuICAgICAgICAgIGFkanVzdG1lbnRzOiB2b2lkIDAsXG4gICAgICAgICAgYmVoYXZpb3I6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bnN1YnMucHVzaChcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub2JzZXJ2ZUVsZW1lbnRSZWN0KHRoaXMsIChyZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbFJlY3QgPSByZWN0O1xuICAgICAgICAgICAgdGhpcy5tYXliZU5vdGlmeSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMudW5zdWJzLnB1c2goXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm9ic2VydmVFbGVtZW50T2Zmc2V0KHRoaXMsIChvZmZzZXQsIGlzU2Nyb2xsaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEFkanVzdG1lbnRzID0gMDtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aW9uID0gaXNTY3JvbGxpbmcgPyB0aGlzLmdldFNjcm9sbE9mZnNldCgpIDwgb2Zmc2V0ID8gXCJmb3J3YXJkXCIgOiBcImJhY2t3YXJkXCIgOiBudWxsO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB0aGlzLmlzU2Nyb2xsaW5nID0gaXNTY3JvbGxpbmc7XG4gICAgICAgICAgICB0aGlzLm1heWJlTm90aWZ5KCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxSZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjcm9sbFJlY3QgPSB0aGlzLnNjcm9sbFJlY3QgPz8gdGhpcy5vcHRpb25zLmluaXRpYWxSZWN0O1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUmVjdFt0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdO1xuICAgIH07XG4gICAgdGhpcy5nZXRTY3JvbGxPZmZzZXQgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsT2Zmc2V0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICB0aGlzLnNjcm9sbE9mZnNldCA9IHRoaXMuc2Nyb2xsT2Zmc2V0ID8/ICh0eXBlb2YgdGhpcy5vcHRpb25zLmluaXRpYWxPZmZzZXQgPT09IFwiZnVuY3Rpb25cIiA/IHRoaXMub3B0aW9ucy5pbml0aWFsT2Zmc2V0KCkgOiB0aGlzLm9wdGlvbnMuaW5pdGlhbE9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5zY3JvbGxPZmZzZXQ7XG4gICAgfTtcbiAgICB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQgPSAobWVhc3VyZW1lbnRzLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBmdXJ0aGVzdE1lYXN1cmVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGxldCBtID0gaW5kZXggLSAxOyBtID49IDA7IG0tLSkge1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1ttXTtcbiAgICAgICAgaWYgKGZ1cnRoZXN0TWVhc3VyZW1lbnRzRm91bmQuaGFzKG1lYXN1cmVtZW50LmxhbmUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50ID0gZnVydGhlc3RNZWFzdXJlbWVudHMuZ2V0KFxuICAgICAgICAgIG1lYXN1cmVtZW50LmxhbmVcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudCA9PSBudWxsIHx8IG1lYXN1cmVtZW50LmVuZCA+IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50cy5zZXQobWVhc3VyZW1lbnQubGFuZSwgbWVhc3VyZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1lYXN1cmVtZW50LmVuZCA8IHByZXZpb3VzRnVydGhlc3RNZWFzdXJlbWVudC5lbmQpIHtcbiAgICAgICAgICBmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kLnNldChtZWFzdXJlbWVudC5sYW5lLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnVydGhlc3RNZWFzdXJlbWVudHNGb3VuZC5zaXplID09PSB0aGlzLm9wdGlvbnMubGFuZXMpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1cnRoZXN0TWVhc3VyZW1lbnRzLnNpemUgPT09IHRoaXMub3B0aW9ucy5sYW5lcyA/IEFycmF5LmZyb20oZnVydGhlc3RNZWFzdXJlbWVudHMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgaWYgKGEuZW5kID09PSBiLmVuZCkge1xuICAgICAgICAgIHJldHVybiBhLmluZGV4IC0gYi5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5lbmQgLSBiLmVuZDtcbiAgICAgIH0pWzBdIDogdm9pZCAwO1xuICAgIH07XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudE9wdGlvbnMgPSBtZW1vKFxuICAgICAgKCkgPT4gW1xuICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5wYWRkaW5nU3RhcnQsXG4gICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4sXG4gICAgICAgIHRoaXMub3B0aW9ucy5nZXRJdGVtS2V5LFxuICAgICAgICB0aGlzLm9wdGlvbnMuZW5hYmxlZFxuICAgICAgXSxcbiAgICAgIChjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXksIGVuYWJsZWQpID0+IHtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb3VudCxcbiAgICAgICAgICBwYWRkaW5nU3RhcnQsXG4gICAgICAgICAgc2Nyb2xsTWFyZ2luLFxuICAgICAgICAgIGdldEl0ZW1LZXksXG4gICAgICAgICAgZW5hYmxlZFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBmYWxzZVxuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5nZXRNZWFzdXJlbWVudHMgPSBtZW1vKFxuICAgICAgKCkgPT4gW3RoaXMuZ2V0TWVhc3VyZW1lbnRPcHRpb25zKCksIHRoaXMuaXRlbVNpemVDYWNoZV0sXG4gICAgICAoeyBjb3VudCwgcGFkZGluZ1N0YXJ0LCBzY3JvbGxNYXJnaW4sIGdldEl0ZW1LZXksIGVuYWJsZWQgfSwgaXRlbVNpemVDYWNoZSkgPT4ge1xuICAgICAgICBpZiAoIWVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLm1lYXN1cmVtZW50c0NhY2hlID0gW107XG4gICAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1lYXN1cmVtZW50c0NhY2hlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSB0aGlzLm9wdGlvbnMuaW5pdGlhbE1lYXN1cmVtZW50c0NhY2hlO1xuICAgICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pdGVtU2l6ZUNhY2hlLnNldChpdGVtLmtleSwgaXRlbS5zaXplKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5sZW5ndGggPiAwID8gTWF0aC5taW4oLi4udGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMpIDogMDtcbiAgICAgICAgdGhpcy5wZW5kaW5nTWVhc3VyZWRDYWNoZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRzID0gdGhpcy5tZWFzdXJlbWVudHNDYWNoZS5zbGljZSgwLCBtaW4pO1xuICAgICAgICBmb3IgKGxldCBpID0gbWluOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGdldEl0ZW1LZXkoaSk7XG4gICAgICAgICAgY29uc3QgZnVydGhlc3RNZWFzdXJlbWVudCA9IHRoaXMub3B0aW9ucy5sYW5lcyA9PT0gMSA/IG1lYXN1cmVtZW50c1tpIC0gMV0gOiB0aGlzLmdldEZ1cnRoZXN0TWVhc3VyZW1lbnQobWVhc3VyZW1lbnRzLCBpKTtcbiAgICAgICAgICBjb25zdCBzdGFydCA9IGZ1cnRoZXN0TWVhc3VyZW1lbnQgPyBmdXJ0aGVzdE1lYXN1cmVtZW50LmVuZCArIHRoaXMub3B0aW9ucy5nYXAgOiBwYWRkaW5nU3RhcnQgKyBzY3JvbGxNYXJnaW47XG4gICAgICAgICAgY29uc3QgbWVhc3VyZWRTaXplID0gaXRlbVNpemVDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICBjb25zdCBzaXplID0gdHlwZW9mIG1lYXN1cmVkU2l6ZSA9PT0gXCJudW1iZXJcIiA/IG1lYXN1cmVkU2l6ZSA6IHRoaXMub3B0aW9ucy5lc3RpbWF0ZVNpemUoaSk7XG4gICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBzaXplO1xuICAgICAgICAgIGNvbnN0IGxhbmUgPSBmdXJ0aGVzdE1lYXN1cmVtZW50ID8gZnVydGhlc3RNZWFzdXJlbWVudC5sYW5lIDogaSAlIHRoaXMub3B0aW9ucy5sYW5lcztcbiAgICAgICAgICBtZWFzdXJlbWVudHNbaV0gPSB7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGxhbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZW1lbnRzQ2FjaGUgPSBtZWFzdXJlbWVudHM7XG4gICAgICAgIHJldHVybiBtZWFzdXJlbWVudHM7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldE1lYXN1cmVtZW50c1wiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmNhbGN1bGF0ZVJhbmdlID0gbWVtbyhcbiAgICAgICgpID0+IFtcbiAgICAgICAgdGhpcy5nZXRNZWFzdXJlbWVudHMoKSxcbiAgICAgICAgdGhpcy5nZXRTaXplKCksXG4gICAgICAgIHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCksXG4gICAgICAgIHRoaXMub3B0aW9ucy5sYW5lc1xuICAgICAgXSxcbiAgICAgIChtZWFzdXJlbWVudHMsIG91dGVyU2l6ZSwgc2Nyb2xsT2Zmc2V0LCBsYW5lcykgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZSA9IG1lYXN1cmVtZW50cy5sZW5ndGggPiAwICYmIG91dGVyU2l6ZSA+IDAgPyBjYWxjdWxhdGVSYW5nZSh7XG4gICAgICAgICAgbWVhc3VyZW1lbnRzLFxuICAgICAgICAgIG91dGVyU2l6ZSxcbiAgICAgICAgICBzY3JvbGxPZmZzZXQsXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgfSkgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgXCJjYWxjdWxhdGVSYW5nZVwiLFxuICAgICAgICBkZWJ1ZzogKCkgPT4gdGhpcy5vcHRpb25zLmRlYnVnXG4gICAgICB9XG4gICAgKTtcbiAgICB0aGlzLmdldFZpcnR1YWxJbmRleGVzID0gbWVtbyhcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBudWxsO1xuICAgICAgICBsZXQgZW5kSW5kZXggPSBudWxsO1xuICAgICAgICBjb25zdCByYW5nZSA9IHRoaXMuY2FsY3VsYXRlUmFuZ2UoKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgZW5kSW5kZXggPSByYW5nZS5lbmRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1heWJlTm90aWZ5LnVwZGF0ZURlcHMoW3RoaXMuaXNTY3JvbGxpbmcsIHN0YXJ0SW5kZXgsIGVuZEluZGV4XSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgdGhpcy5vcHRpb25zLnJhbmdlRXh0cmFjdG9yLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vdmVyc2NhbixcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY291bnQsXG4gICAgICAgICAgc3RhcnRJbmRleCxcbiAgICAgICAgICBlbmRJbmRleFxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIChyYW5nZUV4dHJhY3Rvciwgb3ZlcnNjYW4sIGNvdW50LCBzdGFydEluZGV4LCBlbmRJbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gc3RhcnRJbmRleCA9PT0gbnVsbCB8fCBlbmRJbmRleCA9PT0gbnVsbCA/IFtdIDogcmFuZ2VFeHRyYWN0b3Ioe1xuICAgICAgICAgIHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kSW5kZXgsXG4gICAgICAgICAgb3ZlcnNjYW4sXG4gICAgICAgICAgY291bnRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBcImdldFZpcnR1YWxJbmRleGVzXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuaW5kZXhGcm9tRWxlbWVudCA9IChub2RlKSA9PiB7XG4gICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5vcHRpb25zLmluZGV4QXR0cmlidXRlO1xuICAgICAgY29uc3QgaW5kZXhTdHIgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgIGlmICghaW5kZXhTdHIpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBNaXNzaW5nIGF0dHJpYnV0ZSBuYW1lICcke2F0dHJpYnV0ZU5hbWV9PXtpbmRleH0nIG9uIG1lYXN1cmVkIGVsZW1lbnQuYFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VJbnQoaW5kZXhTdHIsIDEwKTtcbiAgICB9O1xuICAgIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gKG5vZGUsIGVudHJ5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhGcm9tRWxlbWVudChub2RlKTtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW2luZGV4XTtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBpdGVtLmtleTtcbiAgICAgIGNvbnN0IHByZXZOb2RlID0gdGhpcy5lbGVtZW50c0NhY2hlLmdldChrZXkpO1xuICAgICAgaWYgKHByZXZOb2RlICE9PSBub2RlKSB7XG4gICAgICAgIGlmIChwcmV2Tm9kZSkge1xuICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKHByZXZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9ic2VydmVyLm9ic2VydmUobm9kZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudHNDYWNoZS5zZXQoa2V5LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMucmVzaXplSXRlbShpbmRleCwgdGhpcy5vcHRpb25zLm1lYXN1cmVFbGVtZW50KG5vZGUsIGVudHJ5LCB0aGlzKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnJlc2l6ZUl0ZW0gPSAoaW5kZXgsIHNpemUpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLm1lYXN1cmVtZW50c0NhY2hlW2luZGV4XTtcbiAgICAgIGlmICghaXRlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemVDYWNoZS5nZXQoaXRlbS5rZXkpID8/IGl0ZW0uc2l6ZTtcbiAgICAgIGNvbnN0IGRlbHRhID0gc2l6ZSAtIGl0ZW1TaXplO1xuICAgICAgaWYgKGRlbHRhICE9PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEFkanVzdFNjcm9sbFBvc2l0aW9uT25JdGVtU2l6ZUNoYW5nZSAhPT0gdm9pZCAwID8gdGhpcy5zaG91bGRBZGp1c3RTY3JvbGxQb3NpdGlvbk9uSXRlbVNpemVDaGFuZ2UoaXRlbSwgZGVsdGEsIHRoaXMpIDogaXRlbS5zdGFydCA8IHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgKyB0aGlzLnNjcm9sbEFkanVzdG1lbnRzKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLm9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbyhcImNvcnJlY3Rpb25cIiwgZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9zY3JvbGxUb09mZnNldCh0aGlzLmdldFNjcm9sbE9mZnNldCgpLCB7XG4gICAgICAgICAgICBhZGp1c3RtZW50czogdGhpcy5zY3JvbGxBZGp1c3RtZW50cyArPSBkZWx0YSxcbiAgICAgICAgICAgIGJlaGF2aW9yOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdNZWFzdXJlZENhY2hlSW5kZXhlcy5wdXNoKGl0ZW0uaW5kZXgpO1xuICAgICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSBuZXcgTWFwKHRoaXMuaXRlbVNpemVDYWNoZS5zZXQoaXRlbS5rZXksIHNpemUpKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5tZWFzdXJlRWxlbWVudCA9IChub2RlKSA9PiB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c0NhY2hlLmZvckVhY2goKGNhY2hlZCwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKCFjYWNoZWQuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudW5vYnNlcnZlKGNhY2hlZCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzQ2FjaGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQobm9kZSwgdm9pZCAwKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1zID0gbWVtbyhcbiAgICAgICgpID0+IFt0aGlzLmdldFZpcnR1YWxJbmRleGVzKCksIHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCldLFxuICAgICAgKGluZGV4ZXMsIG1lYXN1cmVtZW50cykgPT4ge1xuICAgICAgICBjb25zdCB2aXJ0dWFsSXRlbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgayA9IDAsIGxlbiA9IGluZGV4ZXMubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICBjb25zdCBpID0gaW5kZXhlc1trXTtcbiAgICAgICAgICBjb25zdCBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICAgICAgICB2aXJ0dWFsSXRlbXMucHVzaChtZWFzdXJlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZpcnR1YWxJdGVtcztcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFwiZ2V0VmlydHVhbEl0ZW1zXCIsXG4gICAgICAgIGRlYnVnOiAoKSA9PiB0aGlzLm9wdGlvbnMuZGVidWdcbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMuZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQgPSAob2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBtZWFzdXJlbWVudHMgPSB0aGlzLmdldE1lYXN1cmVtZW50cygpO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RVbmRlZmluZWQoXG4gICAgICAgIG1lYXN1cmVtZW50c1tmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaChcbiAgICAgICAgICAwLFxuICAgICAgICAgIG1lYXN1cmVtZW50cy5sZW5ndGggLSAxLFxuICAgICAgICAgIChpbmRleCkgPT4gbm90VW5kZWZpbmVkKG1lYXN1cmVtZW50c1tpbmRleF0pLnN0YXJ0LFxuICAgICAgICAgIG9mZnNldFxuICAgICAgICApXVxuICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuZ2V0T2Zmc2V0Rm9yQWxpZ25tZW50ID0gKHRvT2Zmc2V0LCBhbGlnbiwgaXRlbVNpemUgPSAwKSA9PiB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmdldFNjcm9sbE9mZnNldCgpO1xuICAgICAgaWYgKGFsaWduID09PSBcImF1dG9cIikge1xuICAgICAgICBhbGlnbiA9IHRvT2Zmc2V0ID49IHNjcm9sbE9mZnNldCArIHNpemUgPyBcImVuZFwiIDogXCJzdGFydFwiO1xuICAgICAgfVxuICAgICAgaWYgKGFsaWduID09PSBcImNlbnRlclwiKSB7XG4gICAgICAgIHRvT2Zmc2V0ICs9IChpdGVtU2l6ZSAtIHNpemUpIC8gMjtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09IFwiZW5kXCIpIHtcbiAgICAgICAgdG9PZmZzZXQgLT0gc2l6ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcm9sbFNpemVQcm9wID0gdGhpcy5vcHRpb25zLmhvcml6b250YWwgPyBcInNjcm9sbFdpZHRoXCIgOiBcInNjcm9sbEhlaWdodFwiO1xuICAgICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IHRoaXMuc2Nyb2xsRWxlbWVudCA/IFwiZG9jdW1lbnRcIiBpbiB0aGlzLnNjcm9sbEVsZW1lbnQgPyB0aGlzLnNjcm9sbEVsZW1lbnQuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3Njcm9sbFNpemVQcm9wXSA6IHRoaXMuc2Nyb2xsRWxlbWVudFtzY3JvbGxTaXplUHJvcF0gOiAwO1xuICAgICAgY29uc3QgbWF4T2Zmc2V0ID0gc2Nyb2xsU2l6ZSAtIHNpemU7XG4gICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obWF4T2Zmc2V0LCB0b09mZnNldCksIDApO1xuICAgIH07XG4gICAgdGhpcy5nZXRPZmZzZXRGb3JJbmRleCA9IChpbmRleCwgYWxpZ24gPSBcImF1dG9cIikgPT4ge1xuICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgdGhpcy5vcHRpb25zLmNvdW50IC0gMSkpO1xuICAgICAgY29uc3QgaXRlbSA9IHRoaXMubWVhc3VyZW1lbnRzQ2FjaGVbaW5kZXhdO1xuICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5nZXRTaXplKCk7XG4gICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmdldFNjcm9sbE9mZnNldCgpO1xuICAgICAgaWYgKGFsaWduID09PSBcImF1dG9cIikge1xuICAgICAgICBpZiAoaXRlbS5lbmQgPj0gc2Nyb2xsT2Zmc2V0ICsgc2l6ZSAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kKSB7XG4gICAgICAgICAgYWxpZ24gPSBcImVuZFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW0uc3RhcnQgPD0gc2Nyb2xsT2Zmc2V0ICsgdGhpcy5vcHRpb25zLnNjcm9sbFBhZGRpbmdTdGFydCkge1xuICAgICAgICAgIGFsaWduID0gXCJzdGFydFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbc2Nyb2xsT2Zmc2V0LCBhbGlnbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvT2Zmc2V0ID0gYWxpZ24gPT09IFwiZW5kXCIgPyBpdGVtLmVuZCArIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nRW5kIDogaXRlbS5zdGFydCAtIHRoaXMub3B0aW9ucy5zY3JvbGxQYWRkaW5nU3RhcnQ7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB0aGlzLmdldE9mZnNldEZvckFsaWdubWVudCh0b09mZnNldCwgYWxpZ24sIGl0ZW0uc2l6ZSksXG4gICAgICAgIGFsaWduXG4gICAgICBdO1xuICAgIH07XG4gICAgdGhpcy5pc0R5bmFtaWNNb2RlID0gKCkgPT4gdGhpcy5lbGVtZW50c0NhY2hlLnNpemUgPiAwO1xuICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbFRvSW5kZXhUaW1lb3V0SWQgIT09IG51bGwgJiYgdGhpcy50YXJnZXRXaW5kb3cpIHtcbiAgICAgICAgdGhpcy50YXJnZXRXaW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCk7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleFRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvT2Zmc2V0ID0gKHRvT2Zmc2V0LCB7IGFsaWduID0gXCJzdGFydFwiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2Nyb2xsVG9PZmZzZXQodGhpcy5nZXRPZmZzZXRGb3JBbGlnbm1lbnQodG9PZmZzZXQsIGFsaWduKSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnNjcm9sbFRvSW5kZXggPSAoaW5kZXgsIHsgYWxpZ246IGluaXRpYWxBbGlnbiA9IFwiYXV0b1wiLCBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGluZGV4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIHRoaXMub3B0aW9ucy5jb3VudCAtIDEpKTtcbiAgICAgIHRoaXMuY2FuY2VsU2Nyb2xsVG9JbmRleCgpO1xuICAgICAgaWYgKGJlaGF2aW9yID09PSBcInNtb290aFwiICYmIHRoaXMuaXNEeW5hbWljTW9kZSgpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBgc21vb3RoYCBzY3JvbGwgYmVoYXZpb3IgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCB3aXRoIGR5bmFtaWMgc2l6ZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2V0QW5kQWxpZ24gPSB0aGlzLmdldE9mZnNldEZvckluZGV4KGluZGV4LCBpbml0aWFsQWxpZ24pO1xuICAgICAgaWYgKCFvZmZzZXRBbmRBbGlnbikgcmV0dXJuO1xuICAgICAgY29uc3QgW29mZnNldCwgYWxpZ25dID0gb2Zmc2V0QW5kQWxpZ247XG4gICAgICB0aGlzLl9zY3JvbGxUb09mZnNldChvZmZzZXQsIHsgYWRqdXN0bWVudHM6IHZvaWQgMCwgYmVoYXZpb3IgfSk7XG4gICAgICBpZiAoYmVoYXZpb3IgIT09IFwic21vb3RoXCIgJiYgdGhpcy5pc0R5bmFtaWNNb2RlKCkgJiYgdGhpcy50YXJnZXRXaW5kb3cpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gdGhpcy50YXJnZXRXaW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb0luZGV4VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICBjb25zdCBlbGVtZW50SW5ET00gPSB0aGlzLmVsZW1lbnRzQ2FjaGUuaGFzKFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmdldEl0ZW1LZXkoaW5kZXgpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZWxlbWVudEluRE9NKSB7XG4gICAgICAgICAgICBjb25zdCBbbGF0ZXN0T2Zmc2V0XSA9IG5vdFVuZGVmaW5lZChcbiAgICAgICAgICAgICAgdGhpcy5nZXRPZmZzZXRGb3JJbmRleChpbmRleCwgYWxpZ24pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFhcHByb3hFcXVhbChsYXRlc3RPZmZzZXQsIHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9JbmRleChpbmRleCwgeyBhbGlnbiwgYmVoYXZpb3IgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsQnkgPSAoZGVsdGEsIHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICB0aGlzLmNhbmNlbFNjcm9sbFRvSW5kZXgoKTtcbiAgICAgIGlmIChiZWhhdmlvciA9PT0gXCJzbW9vdGhcIiAmJiB0aGlzLmlzRHluYW1pY01vZGUoKSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgYHNtb290aGAgc2Nyb2xsIGJlaGF2aW9yIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgd2l0aCBkeW5hbWljIHNpemUuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0KHRoaXMuZ2V0U2Nyb2xsT2Zmc2V0KCkgKyBkZWx0YSwge1xuICAgICAgICBhZGp1c3RtZW50czogdm9pZCAwLFxuICAgICAgICBiZWhhdmlvclxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmdldFRvdGFsU2l6ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IG1lYXN1cmVtZW50cyA9IHRoaXMuZ2V0TWVhc3VyZW1lbnRzKCk7XG4gICAgICBsZXQgZW5kO1xuICAgICAgaWYgKG1lYXN1cmVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZW5kID0gdGhpcy5vcHRpb25zLnBhZGRpbmdTdGFydDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmxhbmVzID09PSAxKSB7XG4gICAgICAgIGVuZCA9ICgoX2EgPSBtZWFzdXJlbWVudHNbbWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZW5kKSA/PyAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZW5kQnlMYW5lID0gQXJyYXkodGhpcy5vcHRpb25zLmxhbmVzKS5maWxsKG51bGwpO1xuICAgICAgICBsZXQgZW5kSW5kZXggPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGVuZEluZGV4ID4gMCAmJiBlbmRCeUxhbmUuc29tZSgodmFsKSA9PiB2YWwgPT09IG51bGwpKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IG1lYXN1cmVtZW50c1tlbmRJbmRleF07XG4gICAgICAgICAgaWYgKGVuZEJ5TGFuZVtpdGVtLmxhbmVdID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmRCeUxhbmVbaXRlbS5sYW5lXSA9IGl0ZW0uZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmRJbmRleC0tO1xuICAgICAgICB9XG4gICAgICAgIGVuZCA9IE1hdGgubWF4KC4uLmVuZEJ5TGFuZS5maWx0ZXIoKHZhbCkgPT4gdmFsICE9PSBudWxsKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAgIGVuZCAtIHRoaXMub3B0aW9ucy5zY3JvbGxNYXJnaW4gKyB0aGlzLm9wdGlvbnMucGFkZGluZ0VuZCxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9O1xuICAgIHRoaXMuX3Njcm9sbFRvT2Zmc2V0ID0gKG9mZnNldCwge1xuICAgICAgYWRqdXN0bWVudHMsXG4gICAgICBiZWhhdmlvclxuICAgIH0pID0+IHtcbiAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGxUb0ZuKG9mZnNldCwgeyBiZWhhdmlvciwgYWRqdXN0bWVudHMgfSwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLm1lYXN1cmUgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1TaXplQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5ub3RpZnkoZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5zZXRPcHRpb25zKG9wdHMpO1xuICB9XG59XG5jb25zdCBmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCA9IChsb3csIGhpZ2gsIGdldEN1cnJlbnRWYWx1ZSwgdmFsdWUpID0+IHtcbiAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgY29uc3QgbWlkZGxlID0gKGxvdyArIGhpZ2gpIC8gMiB8IDA7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gZ2V0Q3VycmVudFZhbHVlKG1pZGRsZSk7XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSA8IHZhbHVlKSB7XG4gICAgICBsb3cgPSBtaWRkbGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbHVlID4gdmFsdWUpIHtcbiAgICAgIGhpZ2ggPSBtaWRkbGUgLSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWlkZGxlO1xuICAgIH1cbiAgfVxuICBpZiAobG93ID4gMCkge1xuICAgIHJldHVybiBsb3cgLSAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuZnVuY3Rpb24gY2FsY3VsYXRlUmFuZ2Uoe1xuICBtZWFzdXJlbWVudHMsXG4gIG91dGVyU2l6ZSxcbiAgc2Nyb2xsT2Zmc2V0LFxuICBsYW5lc1xufSkge1xuICBjb25zdCBsYXN0SW5kZXggPSBtZWFzdXJlbWVudHMubGVuZ3RoIC0gMTtcbiAgY29uc3QgZ2V0T2Zmc2V0ID0gKGluZGV4KSA9PiBtZWFzdXJlbWVudHNbaW5kZXhdLnN0YXJ0O1xuICBsZXQgc3RhcnRJbmRleCA9IGZpbmROZWFyZXN0QmluYXJ5U2VhcmNoKFxuICAgIDAsXG4gICAgbGFzdEluZGV4LFxuICAgIGdldE9mZnNldCxcbiAgICBzY3JvbGxPZmZzZXRcbiAgKTtcbiAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleDtcbiAgaWYgKGxhbmVzID09PSAxKSB7XG4gICAgd2hpbGUgKGVuZEluZGV4IDwgbGFzdEluZGV4ICYmIG1lYXN1cmVtZW50c1tlbmRJbmRleF0uZW5kIDwgc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKSB7XG4gICAgICBlbmRJbmRleCsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsYW5lcyA+IDEpIHtcbiAgICBjb25zdCBlbmRQZXJMYW5lID0gQXJyYXkobGFuZXMpLmZpbGwoMCk7XG4gICAgd2hpbGUgKGVuZEluZGV4IDwgbGFzdEluZGV4ICYmIGVuZFBlckxhbmUuc29tZSgocG9zKSA9PiBwb3MgPCBzY3JvbGxPZmZzZXQgKyBvdXRlclNpemUpKSB7XG4gICAgICBjb25zdCBpdGVtID0gbWVhc3VyZW1lbnRzW2VuZEluZGV4XTtcbiAgICAgIGVuZFBlckxhbmVbaXRlbS5sYW5lXSA9IGl0ZW0uZW5kO1xuICAgICAgZW5kSW5kZXgrKztcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRQZXJMYW5lID0gQXJyYXkobGFuZXMpLmZpbGwoc2Nyb2xsT2Zmc2V0ICsgb3V0ZXJTaXplKTtcbiAgICB3aGlsZSAoc3RhcnRJbmRleCA+IDAgJiYgc3RhcnRQZXJMYW5lLnNvbWUoKHBvcykgPT4gcG9zID49IHNjcm9sbE9mZnNldCkpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBtZWFzdXJlbWVudHNbc3RhcnRJbmRleF07XG4gICAgICBzdGFydFBlckxhbmVbaXRlbS5sYW5lXSA9IGl0ZW0uc3RhcnQ7XG4gICAgICBzdGFydEluZGV4LS07XG4gICAgfVxuICAgIHN0YXJ0SW5kZXggPSBNYXRoLm1heCgwLCBzdGFydEluZGV4IC0gc3RhcnRJbmRleCAlIGxhbmVzKTtcbiAgICBlbmRJbmRleCA9IE1hdGgubWluKGxhc3RJbmRleCwgZW5kSW5kZXggKyAobGFuZXMgLSAxIC0gZW5kSW5kZXggJSBsYW5lcykpO1xuICB9XG4gIHJldHVybiB7IHN0YXJ0SW5kZXgsIGVuZEluZGV4IH07XG59XG5leHBvcnQge1xuICBWaXJ0dWFsaXplcixcbiAgYXBwcm94RXF1YWwsXG4gIGRlYm91bmNlLFxuICBkZWZhdWx0S2V5RXh0cmFjdG9yLFxuICBkZWZhdWx0UmFuZ2VFeHRyYWN0b3IsXG4gIGVsZW1lbnRTY3JvbGwsXG4gIG1lYXN1cmVFbGVtZW50LFxuICBtZW1vLFxuICBub3RVbmRlZmluZWQsXG4gIG9ic2VydmVFbGVtZW50T2Zmc2V0LFxuICBvYnNlcnZlRWxlbWVudFJlY3QsXG4gIG9ic2VydmVXaW5kb3dPZmZzZXQsXG4gIG9ic2VydmVXaW5kb3dSZWN0LFxuICB3aW5kb3dTY3JvbGxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJkZWJvdW5jZSIsIm1lbW8iLCJub3RVbmRlZmluZWQiLCJhcHByb3hFcXVhbCIsImRlZmF1bHRLZXlFeHRyYWN0b3IiLCJpbmRleCIsImRlZmF1bHRSYW5nZUV4dHJhY3RvciIsInJhbmdlIiwic3RhcnQiLCJNYXRoIiwibWF4Iiwic3RhcnRJbmRleCIsIm92ZXJzY2FuIiwiZW5kIiwibWluIiwiZW5kSW5kZXgiLCJjb3VudCIsImFyciIsImkiLCJwdXNoIiwib2JzZXJ2ZUVsZW1lbnRSZWN0IiwiaW5zdGFuY2UiLCJjYiIsImVsZW1lbnQiLCJzY3JvbGxFbGVtZW50IiwidGFyZ2V0V2luZG93IiwiaGFuZGxlciIsInJlY3QiLCJ3aWR0aCIsImhlaWdodCIsInJvdW5kIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlciIsImVudHJpZXMiLCJydW4iLCJlbnRyeSIsImJvcmRlckJveFNpemUiLCJib3giLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwib3B0aW9ucyIsInVzZUFuaW1hdGlvbkZyYW1lV2l0aFJlc2l6ZU9ic2VydmVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsImFkZEV2ZW50TGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZSIsIm9ic2VydmVXaW5kb3dSZWN0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzdXBwb3J0c1Njcm9sbGVuZCIsIndpbmRvdyIsIm9ic2VydmVFbGVtZW50T2Zmc2V0Iiwib2Zmc2V0IiwiZmFsbGJhY2siLCJ1c2VTY3JvbGxlbmRFdmVudCIsImlzU2Nyb2xsaW5nUmVzZXREZWxheSIsImNyZWF0ZUhhbmRsZXIiLCJpc1Njcm9sbGluZyIsImhvcml6b250YWwiLCJpc1J0bCIsImVuZEhhbmRsZXIiLCJyZWdpc3RlclNjcm9sbGVuZEV2ZW50Iiwib2JzZXJ2ZVdpbmRvd09mZnNldCIsIm1lYXN1cmVFbGVtZW50Iiwic2l6ZSIsIndpbmRvd1Njcm9sbCIsImFkanVzdG1lbnRzIiwiYmVoYXZpb3IiLCJfYSIsIl9iIiwidG9PZmZzZXQiLCJzY3JvbGxUbyIsImNhbGwiLCJlbGVtZW50U2Nyb2xsIiwiVmlydHVhbGl6ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJ1bnN1YnMiLCJzY3JvbGxUb0luZGV4VGltZW91dElkIiwibWVhc3VyZW1lbnRzQ2FjaGUiLCJpdGVtU2l6ZUNhY2hlIiwiTWFwIiwicGVuZGluZ01lYXN1cmVkQ2FjaGVJbmRleGVzIiwic2Nyb2xsUmVjdCIsInNjcm9sbE9mZnNldCIsInNjcm9sbERpcmVjdGlvbiIsInNjcm9sbEFkanVzdG1lbnRzIiwiZWxlbWVudHNDYWNoZSIsIl9ybyIsImdldCIsImZvckVhY2giLCJfbWVhc3VyZUVsZW1lbnQiLCJ0YXJnZXQiLCJkaXNjb25uZWN0Iiwic2V0T3B0aW9ucyIsIm9wdHMyIiwiT2JqZWN0Iiwia2V5IiwidmFsdWUiLCJkZWJ1ZyIsImluaXRpYWxPZmZzZXQiLCJwYWRkaW5nU3RhcnQiLCJwYWRkaW5nRW5kIiwic2Nyb2xsUGFkZGluZ1N0YXJ0Iiwic2Nyb2xsUGFkZGluZ0VuZCIsImdldEl0ZW1LZXkiLCJyYW5nZUV4dHJhY3RvciIsIm9uQ2hhbmdlIiwiaW5pdGlhbFJlY3QiLCJzY3JvbGxNYXJnaW4iLCJnYXAiLCJpbmRleEF0dHJpYnV0ZSIsImluaXRpYWxNZWFzdXJlbWVudHNDYWNoZSIsImxhbmVzIiwiZW5hYmxlZCIsIm5vdGlmeSIsInN5bmMiLCJtYXliZU5vdGlmeSIsImNhbGN1bGF0ZVJhbmdlIiwicHJvY2VzcyIsImluaXRpYWxEZXBzIiwiY2xlYW51cCIsImZpbHRlciIsIkJvb2xlYW4iLCJkIiwiX2RpZE1vdW50IiwiX3dpbGxVcGRhdGUiLCJnZXRTY3JvbGxFbGVtZW50Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiY2FjaGVkIiwiX3Njcm9sbFRvT2Zmc2V0IiwiZ2V0U2Nyb2xsT2Zmc2V0IiwiZ2V0U2l6ZSIsImdldEZ1cnRoZXN0TWVhc3VyZW1lbnQiLCJtZWFzdXJlbWVudHMiLCJmdXJ0aGVzdE1lYXN1cmVtZW50c0ZvdW5kIiwiZnVydGhlc3RNZWFzdXJlbWVudHMiLCJtIiwibWVhc3VyZW1lbnQiLCJoYXMiLCJsYW5lIiwicHJldmlvdXNGdXJ0aGVzdE1lYXN1cmVtZW50Iiwic2V0IiwiQXJyYXkiLCJmcm9tIiwidmFsdWVzIiwic29ydCIsImEiLCJiIiwiZ2V0TWVhc3VyZW1lbnRPcHRpb25zIiwiZ2V0TWVhc3VyZW1lbnRzIiwiY2xlYXIiLCJsZW5ndGgiLCJpdGVtIiwic2xpY2UiLCJmdXJ0aGVzdE1lYXN1cmVtZW50IiwibWVhc3VyZWRTaXplIiwiZXN0aW1hdGVTaXplIiwib3V0ZXJTaXplIiwiZ2V0VmlydHVhbEluZGV4ZXMiLCJ1cGRhdGVEZXBzIiwiaW5kZXhGcm9tRWxlbWVudCIsIm5vZGUiLCJhdHRyaWJ1dGVOYW1lIiwiaW5kZXhTdHIiLCJnZXRBdHRyaWJ1dGUiLCJjb25zb2xlIiwid2FybiIsInBhcnNlSW50IiwicHJldk5vZGUiLCJpc0Nvbm5lY3RlZCIsInJlc2l6ZUl0ZW0iLCJpdGVtU2l6ZSIsImRlbHRhIiwic2hvdWxkQWRqdXN0U2Nyb2xsUG9zaXRpb25Pbkl0ZW1TaXplQ2hhbmdlIiwiaW5mbyIsImRlbGV0ZSIsImdldFZpcnR1YWxJdGVtcyIsImluZGV4ZXMiLCJ2aXJ0dWFsSXRlbXMiLCJrIiwibGVuIiwiZ2V0VmlydHVhbEl0ZW1Gb3JPZmZzZXQiLCJmaW5kTmVhcmVzdEJpbmFyeVNlYXJjaCIsImdldE9mZnNldEZvckFsaWdubWVudCIsImFsaWduIiwic2Nyb2xsU2l6ZVByb3AiLCJzY3JvbGxTaXplIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJtYXhPZmZzZXQiLCJnZXRPZmZzZXRGb3JJbmRleCIsImlzRHluYW1pY01vZGUiLCJjYW5jZWxTY3JvbGxUb0luZGV4IiwiY2xlYXJUaW1lb3V0Iiwic2Nyb2xsVG9PZmZzZXQiLCJzY3JvbGxUb0luZGV4IiwiaW5pdGlhbEFsaWduIiwib2Zmc2V0QW5kQWxpZ24iLCJzZXRUaW1lb3V0IiwiZWxlbWVudEluRE9NIiwibGF0ZXN0T2Zmc2V0Iiwic2Nyb2xsQnkiLCJnZXRUb3RhbFNpemUiLCJlbmRCeUxhbmUiLCJmaWxsIiwic29tZSIsInZhbCIsInNjcm9sbFRvRm4iLCJtZWFzdXJlIiwibG93IiwiaGlnaCIsImdldEN1cnJlbnRWYWx1ZSIsIm1pZGRsZSIsImN1cnJlbnRWYWx1ZSIsImxhc3RJbmRleCIsImdldE9mZnNldCIsImVuZFBlckxhbmUiLCJwb3MiLCJzdGFydFBlckxhbmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tanstack/virtual-core/dist/esm/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   approxEqual: () => (/* binding */ approxEqual),\n/* harmony export */   debounce: () => (/* binding */ debounce),\n/* harmony export */   memo: () => (/* binding */ memo),\n/* harmony export */   notUndefined: () => (/* binding */ notUndefined)\n/* harmony export */ });\nfunction memo(getDeps, fn, opts) {\n    let deps = opts.initialDeps ?? [];\n    let result;\n    function memoizedFunction() {\n        var _a, _b, _c, _d;\n        let depTime;\n        if (opts.key && ((_a = opts.debug) == null ? void 0 : _a.call(opts))) depTime = Date.now();\n        const newDeps = getDeps();\n        const depsChanged = newDeps.length !== deps.length || newDeps.some((dep, index)=>deps[index] !== dep);\n        if (!depsChanged) {\n            return result;\n        }\n        deps = newDeps;\n        let resultTime;\n        if (opts.key && ((_b = opts.debug) == null ? void 0 : _b.call(opts))) resultTime = Date.now();\n        result = fn(...newDeps);\n        if (opts.key && ((_c = opts.debug) == null ? void 0 : _c.call(opts))) {\n            const depEndTime = Math.round((Date.now() - depTime) * 100) / 100;\n            const resultEndTime = Math.round((Date.now() - resultTime) * 100) / 100;\n            const resultFpsPercentage = resultEndTime / 16;\n            const pad = (str, num)=>{\n                str = String(str);\n                while(str.length < num){\n                    str = \" \" + str;\n                }\n                return str;\n            };\n            console.info(`%c⏱ ${pad(resultEndTime, 5)} /${pad(depEndTime, 5)} ms`, `\n            font-size: .6rem;\n            font-weight: bold;\n            color: hsl(${Math.max(0, Math.min(120 - 120 * resultFpsPercentage, 120))}deg 100% 31%);`, opts == null ? void 0 : opts.key);\n        }\n        (_d = opts == null ? void 0 : opts.onChange) == null ? void 0 : _d.call(opts, result);\n        return result;\n    }\n    memoizedFunction.updateDeps = (newDeps)=>{\n        deps = newDeps;\n    };\n    return memoizedFunction;\n}\nfunction notUndefined(value, msg) {\n    if (value === void 0) {\n        throw new Error(`Unexpected undefined${msg ? `: ${msg}` : \"\"}`);\n    } else {\n        return value;\n    }\n}\nconst approxEqual = (a, b)=>Math.abs(a - b) < 1;\nconst debounce = (targetWindow, fn, ms)=>{\n    let timeoutId;\n    return function(...args) {\n        targetWindow.clearTimeout(timeoutId);\n        timeoutId = targetWindow.setTimeout(()=>fn.apply(this, args), ms);\n    };\n};\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhbnN0YWNrL3ZpcnR1YWwtY29yZS9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUEsU0FBU0EsS0FBS0MsT0FBTyxFQUFFQyxFQUFFLEVBQUVDLElBQUk7SUFDN0IsSUFBSUMsT0FBT0QsS0FBS0UsV0FBVyxJQUFJLEVBQUU7SUFDakMsSUFBSUM7SUFDSixTQUFTQztRQUNQLElBQUlDLElBQUlDLElBQUlDLElBQUlDO1FBQ2hCLElBQUlDO1FBQ0osSUFBSVQsS0FBS1UsR0FBRyxJQUFLLEVBQUNMLEtBQUtMLEtBQUtXLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSU4sR0FBR08sSUFBSSxDQUFDWixLQUFJLEdBQUlTLFVBQVVJLEtBQUtDLEdBQUc7UUFDeEYsTUFBTUMsVUFBVWpCO1FBQ2hCLE1BQU1rQixjQUFjRCxRQUFRRSxNQUFNLEtBQUtoQixLQUFLZ0IsTUFBTSxJQUFJRixRQUFRRyxJQUFJLENBQUMsQ0FBQ0MsS0FBS0MsUUFBVW5CLElBQUksQ0FBQ21CLE1BQU0sS0FBS0Q7UUFDbkcsSUFBSSxDQUFDSCxhQUFhO1lBQ2hCLE9BQU9iO1FBQ1Q7UUFDQUYsT0FBT2M7UUFDUCxJQUFJTTtRQUNKLElBQUlyQixLQUFLVSxHQUFHLElBQUssRUFBQ0osS0FBS04sS0FBS1csS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJTCxHQUFHTSxJQUFJLENBQUNaLEtBQUksR0FBSXFCLGFBQWFSLEtBQUtDLEdBQUc7UUFDM0ZYLFNBQVNKLE1BQU1nQjtRQUNmLElBQUlmLEtBQUtVLEdBQUcsSUFBSyxFQUFDSCxLQUFLUCxLQUFLVyxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUlKLEdBQUdLLElBQUksQ0FBQ1osS0FBSSxHQUFJO1lBQ3BFLE1BQU1zQixhQUFhQyxLQUFLQyxLQUFLLENBQUMsQ0FBQ1gsS0FBS0MsR0FBRyxLQUFLTCxPQUFNLElBQUssT0FBTztZQUM5RCxNQUFNZ0IsZ0JBQWdCRixLQUFLQyxLQUFLLENBQUMsQ0FBQ1gsS0FBS0MsR0FBRyxLQUFLTyxVQUFTLElBQUssT0FBTztZQUNwRSxNQUFNSyxzQkFBc0JELGdCQUFnQjtZQUM1QyxNQUFNRSxNQUFNLENBQUNDLEtBQUtDO2dCQUNoQkQsTUFBTUUsT0FBT0Y7Z0JBQ2IsTUFBT0EsSUFBSVgsTUFBTSxHQUFHWSxJQUFLO29CQUN2QkQsTUFBTSxNQUFNQTtnQkFDZDtnQkFDQSxPQUFPQTtZQUNUO1lBQ0FHLFFBQVFDLElBQUksQ0FDVixDQUFDLElBQUksRUFBRUwsSUFBSUYsZUFBZSxHQUFHLEVBQUUsRUFBRUUsSUFBSUwsWUFBWSxHQUFHLEdBQUcsQ0FBQyxFQUN4RCxDQUFDOzs7dUJBR2MsRUFBRUMsS0FBS1UsR0FBRyxDQUN2QixHQUNBVixLQUFLVyxHQUFHLENBQUMsTUFBTSxNQUFNUixxQkFBcUIsTUFDMUMsY0FBYyxDQUFDLEVBQ2pCMUIsUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBS1UsR0FBRztRQUVwQztRQUNDRixDQUFBQSxLQUFLUixRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLbUMsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJM0IsR0FBR0ksSUFBSSxDQUFDWixNQUFNRztRQUM5RSxPQUFPQTtJQUNUO0lBQ0FDLGlCQUFpQmdDLFVBQVUsR0FBRyxDQUFDckI7UUFDN0JkLE9BQU9jO0lBQ1Q7SUFDQSxPQUFPWDtBQUNUO0FBQ0EsU0FBU2lDLGFBQWFDLEtBQUssRUFBRUMsR0FBRztJQUM5QixJQUFJRCxVQUFVLEtBQUssR0FBRztRQUNwQixNQUFNLElBQUlFLE1BQU0sQ0FBQyxvQkFBb0IsRUFBRUQsTUFBTSxDQUFDLEVBQUUsRUFBRUEsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQ2hFLE9BQU87UUFDTCxPQUFPRDtJQUNUO0FBQ0Y7QUFDQSxNQUFNRyxjQUFjLENBQUNDLEdBQUdDLElBQU1wQixLQUFLcUIsR0FBRyxDQUFDRixJQUFJQyxLQUFLO0FBQ2hELE1BQU1FLFdBQVcsQ0FBQ0MsY0FBYy9DLElBQUlnRDtJQUNsQyxJQUFJQztJQUNKLE9BQU8sU0FBUyxHQUFHQyxJQUFJO1FBQ3JCSCxhQUFhSSxZQUFZLENBQUNGO1FBQzFCQSxZQUFZRixhQUFhSyxVQUFVLENBQUMsSUFBTXBELEdBQUdxRCxLQUFLLENBQUMsSUFBSSxFQUFFSCxPQUFPRjtJQUNsRTtBQUNGO0FBTUUsQ0FDRixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sZS1tb25kZS1zdWNyZS1kZS1saW5kYS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGFuc3RhY2svdmlydHVhbC1jb3JlL2Rpc3QvZXNtL3V0aWxzLmpzPzQ5NzIiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbWVtbyhnZXREZXBzLCBmbiwgb3B0cykge1xuICBsZXQgZGVwcyA9IG9wdHMuaW5pdGlhbERlcHMgPz8gW107XG4gIGxldCByZXN1bHQ7XG4gIGZ1bmN0aW9uIG1lbW9pemVkRnVuY3Rpb24oKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGxldCBkZXBUaW1lO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9hID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0cykpKSBkZXBUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBuZXdEZXBzID0gZ2V0RGVwcygpO1xuICAgIGNvbnN0IGRlcHNDaGFuZ2VkID0gbmV3RGVwcy5sZW5ndGggIT09IGRlcHMubGVuZ3RoIHx8IG5ld0RlcHMuc29tZSgoZGVwLCBpbmRleCkgPT4gZGVwc1tpbmRleF0gIT09IGRlcCk7XG4gICAgaWYgKCFkZXBzQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZGVwcyA9IG5ld0RlcHM7XG4gICAgbGV0IHJlc3VsdFRpbWU7XG4gICAgaWYgKG9wdHMua2V5ICYmICgoX2IgPSBvcHRzLmRlYnVnKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbChvcHRzKSkpIHJlc3VsdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlc3VsdCA9IGZuKC4uLm5ld0RlcHMpO1xuICAgIGlmIChvcHRzLmtleSAmJiAoKF9jID0gb3B0cy5kZWJ1ZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLmNhbGwob3B0cykpKSB7XG4gICAgICBjb25zdCBkZXBFbmRUaW1lID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGRlcFRpbWUpICogMTAwKSAvIDEwMDtcbiAgICAgIGNvbnN0IHJlc3VsdEVuZFRpbWUgPSBNYXRoLnJvdW5kKChEYXRlLm5vdygpIC0gcmVzdWx0VGltZSkgKiAxMDApIC8gMTAwO1xuICAgICAgY29uc3QgcmVzdWx0RnBzUGVyY2VudGFnZSA9IHJlc3VsdEVuZFRpbWUgLyAxNjtcbiAgICAgIGNvbnN0IHBhZCA9IChzdHIsIG51bSkgPT4ge1xuICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgICAgd2hpbGUgKHN0ci5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgICBzdHIgPSBcIiBcIiArIHN0cjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfTtcbiAgICAgIGNvbnNvbGUuaW5mbyhcbiAgICAgICAgYCVj4o+xICR7cGFkKHJlc3VsdEVuZFRpbWUsIDUpfSAvJHtwYWQoZGVwRW5kVGltZSwgNSl9IG1zYCxcbiAgICAgICAgYFxuICAgICAgICAgICAgZm9udC1zaXplOiAuNnJlbTtcbiAgICAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICAgICAgY29sb3I6IGhzbCgke01hdGgubWF4KFxuICAgICAgICAgIDAsXG4gICAgICAgICAgTWF0aC5taW4oMTIwIC0gMTIwICogcmVzdWx0RnBzUGVyY2VudGFnZSwgMTIwKVxuICAgICAgICApfWRlZyAxMDAlIDMxJSk7YCxcbiAgICAgICAgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5rZXlcbiAgICAgICk7XG4gICAgfVxuICAgIChfZCA9IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWxsKG9wdHMsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBtZW1vaXplZEZ1bmN0aW9uLnVwZGF0ZURlcHMgPSAobmV3RGVwcykgPT4ge1xuICAgIGRlcHMgPSBuZXdEZXBzO1xuICB9O1xuICByZXR1cm4gbWVtb2l6ZWRGdW5jdGlvbjtcbn1cbmZ1bmN0aW9uIG5vdFVuZGVmaW5lZCh2YWx1ZSwgbXNnKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHVuZGVmaW5lZCR7bXNnID8gYDogJHttc2d9YCA6IFwiXCJ9YCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5jb25zdCBhcHByb3hFcXVhbCA9IChhLCBiKSA9PiBNYXRoLmFicyhhIC0gYikgPCAxO1xuY29uc3QgZGVib3VuY2UgPSAodGFyZ2V0V2luZG93LCBmbiwgbXMpID0+IHtcbiAgbGV0IHRpbWVvdXRJZDtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICB0YXJnZXRXaW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgdGltZW91dElkID0gdGFyZ2V0V2luZG93LnNldFRpbWVvdXQoKCkgPT4gZm4uYXBwbHkodGhpcywgYXJncyksIG1zKTtcbiAgfTtcbn07XG5leHBvcnQge1xuICBhcHByb3hFcXVhbCxcbiAgZGVib3VuY2UsXG4gIG1lbW8sXG4gIG5vdFVuZGVmaW5lZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcFxuIl0sIm5hbWVzIjpbIm1lbW8iLCJnZXREZXBzIiwiZm4iLCJvcHRzIiwiZGVwcyIsImluaXRpYWxEZXBzIiwicmVzdWx0IiwibWVtb2l6ZWRGdW5jdGlvbiIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiZGVwVGltZSIsImtleSIsImRlYnVnIiwiY2FsbCIsIkRhdGUiLCJub3ciLCJuZXdEZXBzIiwiZGVwc0NoYW5nZWQiLCJsZW5ndGgiLCJzb21lIiwiZGVwIiwiaW5kZXgiLCJyZXN1bHRUaW1lIiwiZGVwRW5kVGltZSIsIk1hdGgiLCJyb3VuZCIsInJlc3VsdEVuZFRpbWUiLCJyZXN1bHRGcHNQZXJjZW50YWdlIiwicGFkIiwic3RyIiwibnVtIiwiU3RyaW5nIiwiY29uc29sZSIsImluZm8iLCJtYXgiLCJtaW4iLCJvbkNoYW5nZSIsInVwZGF0ZURlcHMiLCJub3RVbmRlZmluZWQiLCJ2YWx1ZSIsIm1zZyIsIkVycm9yIiwiYXBwcm94RXF1YWwiLCJhIiwiYiIsImFicyIsImRlYm91bmNlIiwidGFyZ2V0V2luZG93IiwibXMiLCJ0aW1lb3V0SWQiLCJhcmdzIiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsImFwcGx5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tanstack/virtual-core/dist/esm/utils.js\n");

/***/ })

};
;